<?xml version="1.0" encoding="ISO-8859-1"?>
  <!DOCTYPE html
            PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
            "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 


 













     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  
     <head>
 
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" type="text/css" href="http://trad4.sourceforge.net/gnu.css" />
<title>
heat_equation_1d - a trad4 application</title>
   </head>
 

<body bgcolor="#FFFFFF" text="#000000" link="#1F00FF" alink="#FF0000" vlink="#9900DD">



<h1 align="center">
heat_equation_1d
</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the_model">The Model</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#operation">Operation</a></li>

</ul>

<hr />

<h2><a name="introduction">Introduction</a></h2>

<p>
The heat equation is part of an important class of problems known as Partial Differential Equations (PDEs). The trad4 implementation uses Finite Difference Methods (FDMs) which along with the trad4 approach means that the system can evolve concurrently.
</p>
<p>
This approach will scale for 2D, 3D or nD models of the heat, wave and convection-diffusion equations, all of which are coming soon.
</p>
<p>
While the 1D heat equation has been discussed extensively elsewhere, I will briefly summarise the problem here.
</p>
<p>
Take a fully insulated metal bar with one dimension (think of a lagged copper wire). Provide an initial heat distribution across the bar, and hold each end at a specific temperature (i.e., using Dirichlet boundary conditions). Now let this bar settle into a steady state, taking snapshots of the temperature distribution across the bar as it evolves over time. We should see the temperature converge on a linear slope between the start and end temperatures.
</p>
<h2><a name="the_model">The Model</a></h2>
<p>
As discussed, we'll be using FDMs for this model.
</p>
<p>
Firstly, we need to create our grid. For this example (worked_example1) we'll be using a very rough grid of 10 elements. Each element will have an x value which won't change through the life of the object, and an y value which will start with our initial conditions and then evolve into equilibrium. 
</p>
<p>
Let's look at the starting values first. Each object has an id, an x value and a y value, where y = cos(2*x), and where y = 0.0 if y < 0.0.
</p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
</p>
<p>
Now we need to compute the next cycle of the system's evolution, and for this well be using the Central Difference Method, the derivation of which won't be given here.
</p>
<p>

We have the state at t=n. At t=n+1, the change in any given element is given by:

<blockquote><pre>
my_change_change = K * ( up_element_y - 2*this_element_y + down_element_y );          (1)
</pre></blockquote>
<p>
So that y at t+1 is given by:
<blockquote><pre>
element_y = element_y + my_change_change;          (2)
</pre></blockquote>
<p>
As discussed above, this first model uses the Dirichlet boundary conditions. This just means that the ends of the bar are held at a specific temperature. The way we visualise this is by imagining an extra ghost element at the edges of our bar, like so:
</p>
<table border="1">
<tr>
<td>id</td>
<td>ghost1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>ghost2</td>
</tr>
<tr>
<td>x</td>
<td>n/a</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
<td>n/a</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
<p>
In this model the edges are given somewhat arbitrary values of ALPHA=0.980067 and BETA=0.0 respectively.
</p>
<p>
It's important to stress that these ghost nodes don't actually exists - they just allow for the equation above to work at the edges. In this way the equation above becomes, for element id=1:

<blockquote><pre>
change_change = K * ( up_element_y - 2*this_element_y + ALPHA );
</pre></blockquote>

</p>
<p>
</p>
</p>
<h2><a name="implementation">Implementation</a></h2>
<p>
<h3>The abstract diagram</h3>
<p>
<img src="heat1d_abstract.jpeg" alt="Heat 1D Abstract Diagram">
</p>
<p>
The change object calculates the change that is applied to the object that subscribes to that change object. It uses the y-value of the object that subscribes to it, plus the y-values of it's neighbouring elements. The change object also subscribes to the singleton data_server object.
</p>
<h3>The concrete diagram</h3>
</p>
<p>
Only 5 nodes are shown below when there are ten nodes in worked_example1. The data_server is not shown on this to keep things simple, but remember every change object also subscribes to a single instance of the data_server.
</p>
<img src="heat1d_concrete.jpeg" alt="Heat 1D Concrete Diagram">
</p>
<p>
As you can see from the concrete diagram, a change object subscribes to three element objects so that it is able to calculate equation (1) above. This change gets fed back in to the element object. As such, this is the first application we've seen that has a feedback loop.
</p>
<h3>The t4 files</h3>
<p>
element.t4:
</p>
<blockquote><pre>
static
    int init
    element_type_enum element_type
    double x
    
sub
    change my_change

pub
    double y 
</pre></blockquote>
<p>
<ul>
<li>init is a flag that indicates whether the system has just started up. If it is a fresh start, the element will seed itself with it's function, in this case y = cos(2*x). If the init flag has been set then element will update itself with the change, so that y = y + change.</li>
<li>element_type controls whether the element is at the START, MIDDLE or END of the bar, and therefore what to do w.r.t. the ghost elements.</li>
<li>x is the input value and is fixed in the database. In worked_example1 this runs from 0.1 to 1.0.</li>
<li>my_change is the change object to which the elemnt subscribes</li>
<li>y is the published values. If the system has just been started this will be cos(2*x). If the system has run through once this will be y = y + change.</li>
</ul>
</p>


<p>
change.t4:
</p>
<blockquote><pre>
sub
    element up_element
    element this_element
    element down_element
   
pub
    double change
</pre></blockquote>
<ul>
<li>up_element is the element to the right of this_element along the bar</li>
<li>this_element it the element to which this change applies</li>
<li>down_element is the element to the left of this_element along the bar</li>
<li>change is the change that should be applied to this_element</li>
</ul>
<h3>A note on the printer</h3>
<p>
An undocumented feature of trad4 has been exploited in this model, and this is heat_equation_1d/objects/printer.c. This is a 'feature' I hacked in to deal with the lack of support for any feeds out of the system. It's undocumented as it takes far too much knowledge of the trad4 internals to use, but I've used it a it's become vital that I get the object order correct when I'm outputting csv files. The trick to using it to get a csv is run the app as:
</p>
<blockquote><pre>
$ heat_equation_1d | egrep '(REZ|DELTA)'
</pre></blockquote>
<p>
As I say it's a hack, but I thought I should at least explain..
</p>
<h2><a name="operation">Operation</a></h2>
<p>
We'll now step through a couple of iterations, examining the log file as we go. The full log file is <a href="https://sourceforge.net/docman/display_doc.php?docid=137336&group_id=202177">here</a> - egrep for '(REZ|DELTA)' if you just want the csv.
</p>
<h3>Start-up</h3>
<blockquote><pre>
</pre></blockquote>
<p>
As per usual, the types are created and their shared objects loaded:
</p>
<blockquote><pre>
Creating new type change, type id: 2, tier: 2
Creating new type element, type id: 1, tier: 1
</pre></blockquote>
<p>
Then, the data is loaded:
</p>
<blockquote><pre>
load_all_changes()
load_all_elements()
</pre></blockquote>
<p>
Next, the system is checked and it's constituents reported:
</p>
<blockquote><pre>
Checking tier 1. Num objects this tier: 10
Checking tier 2. Num objects this tier: 10
Checking tier 3. Num objects this tier: 0
Checking tier 4. Num objects this tier: 0
Checking tier 5. Num objects this tier: 0
</pre></blockquote>
<p>
Next, the objects are validated:
</p>
<blockquote><pre>
Validating objects...
</pre></blockquote>
<p>
Then the threads start:
</p>
<blockquote><pre>
Starting thread 1
Starting thread 2
Starting thread 3
Starting thread 4
</pre></blockquote>
<p>
Then tier1 runs:
</p>
<blockquote><pre>
Tier 1 running.
Tier 1 ran 10 objects in 0.000613928 seconds.
</pre></blockquote>
<p>
At this stage, as it's the first time the system has been run, the init flag will not have been set so the element just calculate their y-values using the equation defined in their calculate method - in this case y = cos(2*x) and where y = 0.0 if y < 0.0. We've seen this before above:
</p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y(t)</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
<p>
</p>
<p>
Then tier 2 runs:
</p>
<blockquote><pre>
Tier 2 running.
Tier 2 ran 10 objects in 0.000543118 seconds.
</pre></blockquote>
<p>
At this stage the deltas are calculated. This is done using equation (1) above, but bear in mind the ghost elements caused by the boundary conditions we've selected. Running this tier will give:
</p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y(t)</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<tr>
<td>change(t)</td>
<td>-0.0236062</td>
<td>-0.0146879</td>
<td>-0.0131614</td>
<td>-0.0111102</td>
<td>-0.00861606</td>
<td>-0.00577842</td>
<td>0.00896939</td>
<td>0.0679869</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
</table>
<p>
And lastly the printer runs, giving the results we've just seen:
</p>
<blockquote><pre>
REZ,0.980067,0.921061,0.825336,0.696707,0.540302,0.362358,0.169967,0,0,0,
DELTA,-0.0236062,-0.0146879,-0.0131614,-0.0111102,-0.00861606,-0.00577842,0.00896939,0.0679869,0,0,
</pre></blockquote>
<p>
<h3>Next iteration</h3>
</p>
Due to the presence of the feedback loop, the system needs no external influence to continue to run. When the T1 element's tier is run, they will see that the objects they subscribe to - the T2 objects - have changed, and that they therefore need to fire. 
<p>
The next thing they will see is that their init flag's been set, and that therefore they will not need to seed themselves, but rather to update their published values given the delta they pull up from the change objects to which they subscribe. This means that equation (2) above runs, which results in:
</p>
<p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y(t)</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr>
<td>change(t)</td>
<td>-0.0236062</td>
<td>-0.0146879</td>
<td>-0.0131614</td>
<td>-0.0111102</td>
<td>-0.00861606</td>
<td>-0.00577842</td>
<td>0.00896939</td>
<td>0.0679869</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<td>y(t+1)</td>
<td>0.95646</td>
<td>0.906373</td>
<td>0.812174</td>
<td>0.685597</td>
<td>0.531686</td>
<td>0.356579</td>
<td>0.178937</td>
<td>0.0679869</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
</table>
</p>
<p>
The change object then fires again as discussed above, which produces:
</p>
<p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y(t)</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr>
<td>change(t)</td>
<td>-0.0236062</td>
<td>-0.0146879</td>
<td>-0.0131614</td>
<td>-0.0111102</td>
<td>-0.00861606</td>
<td>-0.00577842</td>
<td>0.00896939</td>
<td>0.0679869</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<td>y(t+1)</td>
<td>0.95646</td>
<td>0.906373</td>
<td>0.812174</td>
<td>0.685597</td>
<td>0.531686</td>
<td>0.356579</td>
<td>0.178937</td>
<td>0.0679869</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
</tr>
<td>change(t+1)</td>
<td>-0.0105964</td>
<td>-0.0176446</td>
<td>-0.0129515</td>
<td>-0.010933</td>
<td>-0.00847866</td>
<td>-0.00101435</td>
<td>0.0266773</td>
<td>0.0171851</td>
<td>0.0271947</td>
<td>0.000000</td>
</tr>
</table>
</p>
<p>
These changes continue to ripple round the system until the system reaches equilibrium (more on this below).
</p>
</body>
     </html>
