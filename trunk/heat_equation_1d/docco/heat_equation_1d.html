<?xml version="1.0" encoding="ISO-8859-1"?>
  <!DOCTYPE html
            PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
            "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 


 













     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  
     <head>
 
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" type="text/css" href="http://trad4.sourceforge.net/gnu.css" />
<title>
heat_equation_1d - a trad4 application</title>
   </head>
 

<body bgcolor="#FFFFFF" text="#000000" link="#1F00FF" alink="#FF0000" vlink="#9900DD">



<h1 align="center">
heat_equation_1d
</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the_model">The Model</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#operation">Operation</a></li>
<li><a href="#errors_and_stability">Errors and Stability</a></li>

</ul>

<hr />

<h2><a name="introduction">Introduction</a></h2>

<p>
The heat equation is part of an important class of problems known as Partial Differential Equations (PDEs). The trad4 implementation uses Finite Difference Methods (FDMs) which along with the trad4 approach means that the system can evolve concurrently.
</p>
<p>
This approach will scale for 2D, 3D or nD models of the heat, wave and convection-diffusion equations, all of which are coming soon.
</p>
<p>
While the 1D heat equation has been discussed extensively elsewhere, I will briefly summarise the problem here.
</p>
<p>
Take a fully insulated metal bar with one dimension (think of a lagged copper wire). Provide an initial heat distribution across the bar, and hold each end at a specific temperature (i.e., using Dirichlet boundary conditions). Now let this bar settle into a steady state, taking snapshots of the temperature distribution across the bar as it evolves over time. We should see the temperature converge on a linear slope between the start and end temperatures.
</p>
<h2><a name="the_model">The Model</a></h2>
<p>
As discussed, we'll be using FDMs for this model.
</p>
<p>
Firstly, we need to create our grid. For this example (worked_example1) we'll be using a very rough grid of 10 elements. Each element will have an x value which won't change through the life of the object, and an y value which will start with our initial conditions and then evolve into equilibrium. 
</p>
<p>
Let's look at the starting values first. Each object has an id, an x value and a y value, where y = cos(2*x), and where y = 0.0 if y < 0.0.
</p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
</p>
<p>
Now we need to compute the next cycle of the system's evolution, and for this well be using the Central Difference Method, the derivation of which won't be given here.
</p>
<p>

We have the state at t=n. At t=n+1, the change in any given element is given by:

<blockquote><pre>
my_change_change = K * ( up_element_y - 2*this_element_y + down_element_y );          (1)
</pre></blockquote>
<p>
So that y at t+1 is given by:
<blockquote><pre>
element_y = element_y + my_change_change;
</pre></blockquote>
<p>
As discussed above, this first model uses the Dirichlet boundary conditions. This just means that the ends of the bar are held at a specific temperature. The way we visualise this is by imagining an extra ghost element at the edges of our bar, like so:
</p>
<table border="1">
<tr>
<td>id</td>
<td>ghost1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>ghost2</td>
</tr>
<tr>
<td>x</td>
<td>n/a</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
<td>n/a</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
<p>
In this model the edges are given somewhat arbitrary values of ALPHA=0.980067 and BETA=0.0 respectively.
</p>
<p>
It's important to stress that these ghost nodes don't actually exists - they just allow for the equation above to work at the edges. In this way the equation above becomes, for element id=1:

<blockquote><pre>
change_change = K * ( up_element_y - 2*this_element_y + ALPHA );
</pre></blockquote>

</p>
<p>
</p>
</p>
<h2><a name="implementation">Implementation</a></h2>
<p>
<h3>The concrete diagram</h3>
<p>
Only 5 nodes are shown below when there are ten nodes in worked_example1.
</p>
<img src="heat1d_concrete.jpeg" alt="Heat 1D Concrete Diagram">
</p>
<p>
As you can see from the concrete diagram, a change object subscribes to three element objects so that it is able to calculate equation (1) above. This change gets fed back in to the element object. As such, this is the first application we've seen that has a feedback loop.
</p>
<h3>The t4 files</h3>
<p>
element.t4:
</p>
<blockquote><pre>
static
    int init
    element_type_enum element_type
    double x
    
sub
    change my_change

pub
    double y 
</pre></blockquote>
<p>
<ul>
<li>init is a flag that indicates whether the system has just started up. If it is a fresh start, the element will seed itself with it's function, in this case y = cos(2*x). If the init flag has been set then element will update itself with the change, so that y = y + change.</li>
<li>element_type controls whether the element is at the START, MIDDLE or END of the bar, and therefore what to do w.r.t. the ghost elements.</li>
<li>x is the input value and is fixed in the database. In worked_example1 this runs from 0.1 to 1.0.</li>
<li>my_change is the change object to which the elemnt subscribes</li>
<li>y is the published values. If the system has just been started this will be cos(2*x). If the system has run through once this will be y = y + change.</li>
</ul>
</p>


<p>
change.t4:
</p>
<blockquote><pre>
sub
    element up_element
    element this_element
    element down_element
   
pub
    double change
</pre></blockquote>
<ul>
<li>up_element is the element to the right of this_element along the bar</li>
<li>this_element it the element to which this change applies</li>
<li>down_element is the element to the left of this_element along the bar</li>
<li>change is the change that should be applied to this_element</li>
</ul>
<h2><a name="Operation">Operation</a></h2>
<h2><a name="errors_and_stability">Errors and Stability</a></h2>
</body>
     </html>
