<?xml version="1.0" encoding="ISO-8859-1"?>
  <!DOCTYPE html
            PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
            "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 


 













     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  
     <head>
 
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" type="text/css" href="http://trad4.sourceforge.net/gnu.css" />
<title>
heat_equation_1d - a trad4 application</title>
   </head>
 

<body bgcolor="#FFFFFF" text="#000000" link="#1F00FF" alink="#FF0000" vlink="#9900DD">



<h1 align="center">
heat_equation_1d
</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the_model">The Model</a></li>
<li><a href="#implementation">Implementation</a></li>

</ul>

<hr />

<h2><a name="introduction">Introduction</a></h2>

<p>
The heat equation is part of an important class of problems known as Partial Differential Equations (PDEs). The trad4 implementation uses Finite Difference Methods (FDMs) which along with the trad4 approach means that the system can evolve concurrently.
</p>
<p>
This approach will scale for 2D, 3D or nD models of the heat, wave and convection-diffusion equations, all of which are coming soon.
</p>
<p>
While the 1D heat equation has been discussed extensively elsewhere, I will briefly summarise the problem here.
</p>
<p>
Take a fully insulated metal bar with one dimension (think of a lagged copper wire). Provide an initial heat distribution across the bar, and hold each end at a specific temperature (i.e., using Dirichlet boundary conditions). Now let this bar settle into a steady state, taking snapshots of the temperature distribution across the bar as it evolves over time. We should see the temperature converge on a linear slope between the start and end temperatures.
</p>
<h2><a name="the_model">The Model</a></h2>
<p>
As discussed, we'll be using FDMs for this model.
</p>
<p>
Firstly, we need to create our grid. For this example (worked_example1) we'll be using a very rough grid of 10 elements. Each element will have an x value which won't change through the life of the object, and an y value which will start with our initial conditions and then evolve into equilibrium. 
</p>
<p>
Let's look at the starting values first. Each object has an id, an x value and a y value, where y = cos(2*x), and where y = 0.0 if y < 0.0.
</p>
<table border="1">
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>x</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
</p>
<p>
Now we need to compute the next cycle of the system's evolution, and for this well be using the Central Difference Method, the derivation of which won't be given here.
</p>
<p>

We have the state at t=n. At t=n+1, the change in any given element is given by:

<blockquote><pre>
my_change_change = _K * ( up_element_y - 2*this_element_y + down_element_y );
</pre></blockquote>
<p>
So that y at t+1 is given by:
<blockquote><pre>
element_y = element_y + my_change_change;
</pre></blockquote>
<p>
As discussed above, this first model uses the Dirichlet boundary conditions. This just means that the ends of the bar are held at a specific temperature. The way we visualise this is by imagining an extra ghost element at the edges of our bar, like so:
</p>
<table border="1">
<tr>
<td>id</td>
<td>ghost1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>ghost2</td>
</tr>
<tr>
<td>x</td>
<td>n/a</td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
<td>0.4</td>
<td>0.5</td>
<td>0.6</td>
<td>0.7</td>
<td>0.8</td>
<td>0.9</td>
<td>1.0</td>
<td>n/a</td>
</tr>
<tr>
<td>y</td>
<td>0.980067</td>
<td>0.980067</td>
<td>0.921061</td>
<td>0.825336</td>
<td>0.696707</td>
<td>0.540302</td>
<td>0.362358</td>
<td>0.169967</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</table>
<p>
In this model the edges are given somewhat arbitrary values of ALPHA=0.980067 and BETA=0.0 respectively.
</p>
<p>
It's important to stress that these ghost nodes don't actually exists - they just allow for the equation above to work at the edges. In this way the equation above becomes, for element id=1:

<blockquote><pre>
change_change = _K * ( up_element_y - 2*this_element_y + 0.980067 );
</pre></blockquote>

</p>
<p>
</p>
</p>
<h2><a name="implementation">Implementation</a></h2>
<p>
<h3>The concrete diagram</h3>
<img src="heat1d_concrete.jpeg" alt="Heat 1D Concrete Diagram">
<h3>The t4 files</h3>
<p>
element.t4:
</p>
<blockquote><pre>
static
    int init
    element_type_enum element_type
    double x
    
sub
    change my_change

pub
    double y 
</pre></blockquote>

</body>
     </html>
