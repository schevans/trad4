% Copyright (c) Steve Evans 2010
% schevans@users.sourceforge.net

\documentclass{report}

\usepackage{underscore}
\usepackage{times}
\usepackage{graphicx}

\begin{document}

\title{The Manual \\
{\large \textbf{trad4 version 3.3beta01}}}

%\author{Steve Evans \\ Steve has a B.Sc. in Anthropology \\ and an M.Sc. in Computer Science, both from UCL. \\ He is currently working as a Credit Quant Developer at Royal Bank of Scotland. \\ He lives in London.}
\author{Steve Evans \\\\ Steve has a B.Sc. in Anthropology \\ and an M.Sc. in Computer Science, both from UCL. \\ He is currently working as a Credit Quant Developer \\ at Royal Bank of Scotland. He lives in London.}

\date{Document version beta01 \\
\today}

\maketitle



\setcounter{tocdepth}{1}
\tableofcontents

\chapter{Introduction}

Trad4 is a hybrid between dataflow and imperative programming ('imperaflow' programming). A trad4 application is composed of nodes which connect to each other in a directed graph but each node has some imperative code (written in C++) that does something complex with the outputs of the nodes to which is subscribes.

These nodes are arranged in tiers with each tier run one after another from the bottom up. As we know that the nodes on each tier cannot affect one another and that the nodes below are effectively read-only, we can run all the nodes on a particular tier in parallel.

Furthermore, trad4 keeps track of whether a particular node's antecedents have changed since the node last fired and only fires the node if they have.

Each node is of a particular user-defined type. When the type is instantiated it is referred to as an object of that type.

Time for an example.

\includegraphics[scale=0.5]{simplemathsabstract.png}

These objects are held on tiers, so a, b, c and d are on Tier 1 (T1). Objects x and y are on T2 and z is on T3. 

Change is fed into this graph and ripples it's way upward. In the above example, should b change on T1, when T2 is run x will fire but y will not. Then when T3 is run z will fire using the new data from x and the old (but still valid) data from y. Should b and c change then when T2 runs both x and  y will run concurrently. Then z will run as usual on T3.

This brings us us some immediate advantages. 

Firstly, we get the concurrency of x and y should they both need to fire. This becomes particularly useful when there are large numbers of objects. Because this concurrency is restricted to one tier at a time sequentially we have no need for any mutex locks in the system - we know that when running Tn concurrently, all the objects they depend on and read data from are on T($<$n) and won't change during Tn's run.

Second, should b change we don't need to recalculate y - y's object stays in memory throughout the life of the application and will only update if d or c fire, so z object can continue to re-use the results of y which was only calculated once at start-up.. This is particularly useful if y is computationally expensive.

Trad4 applications are supposed to stay up indefinitely - once y has been calculated that's the last time y needs to fire until the application is halted (unless of course c or d change). In practise of course you should stop them occasionally for maintenance - more on this in section 9.

We'll see late how it's possible to decompose arbitrary equations to run as concurrent trad4 applications.

\subsubsection{Programming in trad4}

Trad4 is quite a different kind of programming you may be used to. It has three phases of development.

Firstly, you describe your types\footnote{The terms 'type' and 'object' will be conflated (but used correctly) until section 4, but an object is just an instantiated type. In the above example z is both a type and an object, as there is only one object of type z and that object is called z.}. This information describes both the internal structure of a type (e.g. any doubles ints or arrays it contains), and it's relationship to other types. This relationship is one of subscription - in the above example x subscribes to a and b. Object z subscribes to x and y, but not to the T1 objects.

Then you describe (in C++) what each type does - how it combines it's own data and the data of the objects to which it subscribes into it's published results. This is done in the object's calculate function which has both the object's data and the objects to which it subscribes' data pulled in-scope by trad4. You access this data and publish the results through macro accessors provided for you by trad4.

Lastly, you specify the data for each object in the database. This will include the object name, id, any static data and the ids of the other objects to which this object subscribes.

\subsubsection{Features}

\begin{itemize}
\item add and remove objects at run time
\item add and remove types at run time
\item full lock-free concurrency
\item run-time fault-tolerance
\item 3rd-party library integration (restrictions apply: you have to keep them on the stack)
\end{itemize}

\subsubsection{About this document}

The next four sections are supposed to be read alongside a downloaded, build-able, run-able copy of the source (any v3.3 distribution will at a minimum contain all applications referred to in this document).

In the next section we're going to dive straight in with an example - the venerable Hello World! While this example suppresses a lot of the interesting things about trad4, it will still be a pretty steep learning curve.

The next three sections introduce applications of increasing complexity and introduces new aspects of the trad4 world: Section three covers the above example in more detail; Section four introduces a cut-down example from the world of finance; Section five expands on section four .

Sections six and seven are a reference of language features it's recommended you at least read through.

Section eight describes step-by-step how you go about creating your own trad4 application.

Section nine describes how you would live with a trad4 application on a day-to-day basis.

Lastly, Appendix A describes in detail how trad4 actually works.


\chapter{Hello world!}

\section{Introduction}

The first trad4 application we'll examine is the venerable "Hello world!".

\includegraphics[scale=0.5]{helloworldabstract.png}

The above application is a directed acyclic graph, and it shows three types. Two on tier1 (T1) - hello and world, and one on T2 - hello_world. The T2 hello_world type subscribes to the two T1 types. The hello_world type simply concatenates the names of the two type and prints them out.

In this example each type will be instantiated by a running object, as there is one object per type. This will become clearer later on when we introduce multiple objects of the same type.

What will happen when the application starts is that the T1 objects will run concurrently (they do nothing in this simple example), then the T2 object will run. This will read the names of the T1 objects and concatenate them and print the result. The output is below.

\begin{verbatim}
~/src/hello_world$ hello_world
Creating new type hello, type_id: 1
Creating new type world, type_id: 2
Creating new type hello_world, type_id: 3
Loading objects...
Loading hello..
Loading world..
Loading hello_world..
Validating objects...

Num objects on T1: 2
Num objects on T2: 1

Running in single-threaded mode.

Tier 1 running.
Tier 1 ran 2 objects in 6.60419e-05 seconds.

Tier 2 running.
Hello world!
Tier 2 ran 1 objects in 2.88486e-05 seconds.

All tiers ran 3 objects in 0.000231981 seconds.

Exiting after first run as BATCH_MODE is set.
\end{verbatim}

When the application hello_world starts, it first creates the three types we discussed above. Next the objects themselves are loaded. Next the objects are validated and the number of objects on each tier reported. This application is set to use single-threaded mode to keep the output orderly. 

Next we'll see how these types are defined.

\section{The .t4 files}

The way types are defined is in their *.t4 file in the src directory. The types hello and world are the simplest possible as they do absolutely nothing and thus .t4 files are empty, but hello_world.t4 is shown below:

\begin{verbatim}
sub
    hello hello
    world world
\end{verbatim}

The .t4 files are split into three sections. The sub section as shown above describes the type and name of the other trad4 types to which this this type subscribes. In this case hello_world subscribes to two types, the first being a hello object called hello, and the second a world object called world.

The other two sections are static - where the object keeps it's static data which is loaded from the database, and the pub section - where the intermediate and final values of the object's calculate function are stored and published to the world. Neither of these two sections are used in this simple model.

Each type must also have an entry in the object_types.t4s file (the 's' stands for system). This is shown below:

\begin{verbatim}
#type_id, tier, name
1,1,hello
2,1,world
3,2,hello_world
\end{verbatim}


The type_id must be unique. From this we can see type hello has an type_id of 1 and exists on tier 1 and world has an type_id of 2 and also exists on tier 1. The hello_world type has an type_id of 3 and exists on tier 2.

\section{The calculate function}

Now we have described the type, we must specify what is does, in this case concatenating the names of the two objects and printing it out.

A stub calculate function is generated for you by trad4, and is found in the objects directory. Again, hello and world do nothing but hello_world's calculate function is shown below:

\begin{verbatim}
int calculate_hello_world( obj_loc_t obj_loc, long id )
{
    cout << object_name(hello_world_hello) 
        << " " 
        << object_name(hello_world_world) 
        << "!" << endl;

    return 1;
}
\end{verbatim}

Trad4 pulls all the information from the sub objects into the scope of this function using macros. You need not concern yourself how these macros work, just think of then as variables which will do what you expect. The functions signature is boilerplate to allow the macros to work and can be ignored. Also ignore the return value for now.

In this case there's very little information in the sub objects, just their id. The macros used above are shown below (from gen/objects/hello_world_macros.h):

\begin{verbatim}
sub:
    id hello_world_hello
    id hello_world_world
\end{verbatim}

So this shows that within calculate_hello_world there's a variable hello_world_hello in scope that will return the id of the hello object. Likewise there's a variable hello_world_world that will return the id of the world object. These id's we can use in the trad4 object_name function to return the name of the object, which is exactly what calculate_hello_world does above.

\chapter{Simple maths}

\section{Introduction}

We're going to move on to a more complex example in order to demonstrate the concurrency. We want to model the following simple problem:

\begin{math}
  \begin{array}{ l c }
        & z = x * y   \\
        where         \\
        & x = a + b   \\
        & y = c - d   \\
        and           \\
        & a = 7       \\
        & b = 14      \\
        & c = 27      \\
        & d = 11      \\
  \end{array} 
\end{math}

The abstract graph for simple_maths is as follows:

\includegraphics[scale=0.5]{simplemathsabstract.png}

From this we can see that should a, b, c, and d all change we can run x and y at the same time, followed by z. Likewise, if only a changes we only need to recalculate x. Another point to note it that there is just one instance of \begin{math} a + b\end{math} in the whole system - any other object that requires that result subscribe to the x object and read it from there. We will see later how it's possible to decompose quite complex problems into trad4 applications and have fragments of them run concurrently.

\section{The .t4 Files}

In this example the .t4 files are a little more interesting than before. Below, a.t4:

\begin{verbatim}
static
    int out
\end{verbatim}

Here type a has only one member, it's in the static section and it's an int called out. It's in the static section as the data is stored in the database. More on this below.

The .t4 file for b, c and d are identical to a's and are not shown. The .t4 file for x is shown below:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Here type x has three members. The first two are in the sub section and shows x subscribes to a type a called a, and a type b called b. It also has an int called out in the pub section, where the result of \(a + b\) will be stored to be consumed by z.

The .t4 files for y and z are similar to x's and not shown.

\section{The Calculate Function}

The calculate functions for a, b, c and d do nothing, as the types consist entirely of a single static member which is just published to to the world at large without any processing. 

This information is made available in x's calculate function by the macros (from gen/objects/x_macros.h):

\begin{verbatim}
sub:
    id x_a
    int a_out

    id x_b
    int b_out

static:

pub:
    int x_out
\end{verbatim}

Here you can see for each sub member two variables are provided, in a's case these are x_a which provides it's id, and a_out where a will publish it's static data. Also in the pub section is the int x_out, where the result of  \(a + b\) is published. So calculate_x takes the published a_out and b_out variables, adds them and publishes the result in x_out (from objects/x.c):

\begin{verbatim}
int calculate_x( obj_loc_t obj_loc, long id )
{
    x_out = a_out + b_out;

    return 1;
}
\end{verbatim}

The calculate function for y is very similar to that of x, but it subtracts c_out and d_out. The calculate function for z is shown below, as it includes some output:

\begin{verbatim}
int calculate_z( obj_loc_t obj_loc, long id )
{
    z_out = x_out * y_out;

    cout << "z_out: " << z_out << endl;

    return 1;
}
\end{verbatim}

\section{The data}
\label{sec:The data}

In the first example hello_world we ignored the database to keep things simple, but we need to introduce it now. Trad4 uses sqlite - a serverless database written in C. All the tables you need (and some of the data) are generated for you by the precompiler, but you need to provide the data for.

At this stage we also need to further distinguish between objects and types. Types are the trad4 types as described in their .t4 files and calculate function, and they describe the structure of the database tables. Objects are the running instantiated types, and they each have entries in the database tables which are loaded at start-up.

The main table in the database is the object table, in which every object has an entry. This table is shown below:
 
\begin{verbatim}
create table object (
    id int, 
    type_id int,
    tier int,
    name char(32),
    log_level int,
    need_reload int
);
\end{verbatim}

The id is the unique id of this object. The type_id gives the type of the object, as described in the object_types.t4s file described above. The tier gives the tier this object exists on, as objects of the same type can exist on different tiers in certain circumstances. The name field holds the name of the object which we pressed into service in hello_world. The log_level controls the level of logging the object does, and need_reload controls whether of not the object needs to be reloaded when the application receives a reload signal (more on this later).

As well as the object table, each type has one or more type-specific tables. In simple_maths this is just one table per type. Below is the table for a (from gen/object/sql):


\begin{verbatim}
create table a (
    id int,
    out int
);
\end{verbatim}

There is the primary key id, plus the static value of the out variable. So the data for object a of type a is given by (from data/worked_example/a.sql):

\begin{verbatim}
insert into object values ( 1, 1, 1, "a", 1, 0 );
insert into a values ( 1, 7 );
\end{verbatim}

So we can see an object with id of 1, type 1 running on tier 1 called "a" with log_level 1 and need_reload set to 0. In type-specific table a there's the primary key id and the value of out, given by 7. The data for objects b, c and d are similar to this, except they have different ids, type_ids, names and static out values as described above. The data for object x is given by:


\begin{verbatim}
insert into object values ( 5, 5, 2, "x", 1, 0 );
insert into x values ( 5, 1, 2 );
\end{verbatim}

This shows an object with id 5, type 5, tier 2 etc. In type-specific table x there's the primary key id and the ids of the two objects to which x subscribes, namely a with id 1 and b with id 2. 

Now we have the full description of this application we can run it:

\begin{verbatim}

~/src/simple_maths$ simple_maths
Creating new type y, type_id: 6
Creating new type c, type_id: 3
Creating new type a, type_id: 1
Creating new type b, type_id: 2
Creating new type x, type_id: 5
Creating new type d, type_id: 4
Creating new type z, type_id: 7
Loading objects...
Loading y..
Loading c..
Loading a..
Loading b..
Loading x..
Loading d..
Loading z..
Validating objects...

Num objects on T1: 4
Num objects on T2: 2
Num objects on T3: 1

Running in single-threaded mode.

Tier 1 running.
calculate_a( a )
calculate_b( b )
calculate_c( c )
calculate_d( d )
Tier 1 ran 4 objects in 8.89301e-05 seconds.

Tier 2 running.
calculate_x( x )
calculate_y( y )
Tier 2 ran 2 objects in 4.60148e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 336
Tier 3 ran 1 objects in 3.60012e-05 seconds.

All tiers ran 7 objects in 0.000287056 seconds.

\end{verbatim}

As in the previous example you can see the types being created and the objects being loaded and validated. Then from the report you can see we have 4 objects in T1, 2 on T2 and 1 on T3, as expected. Then the tiers are run as before, with z producing the output 336.

\section{Feeding in change}

In this case the applications doesn't terminate after the first time all the tiers are run, waits for change. We introduce change as follows:

\begin{enumerate}

\item Change the required values in the database and set the need_reload flag.
\item Send the application a signal to indicate something has changed.

\end{enumerate}

So we'll update a's static data and trigger a reload. First we log into the database and make the changes:

\begin{verbatim}

~/src/simple_maths$ t4db
sqlite> update a set out=19 where id=1;
sqlite> update object set need_reload=1 where id=1;

\end{verbatim}

And send the reload signal:

\begin{verbatim}

~/src/simple_maths$ send_reload.sh

\end{verbatim}

This produces the following output:

\begin{verbatim}

Tier 1 running.
calculate_a( a )
Tier 1 ran 1 objects in 5.00679e-05 seconds.

Tier 2 running.
calculate_x( x )
Tier 2 ran 1 objects in 3.91006e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 528
Tier 3 ran 1 objects in 4.19617e-05 seconds.

\end{verbatim}

Notice only a, x and z fired, the minimum needed to recalculate z given that only a had changed. 

Next we'll update b and c (ids 2 and 3):

\begin{verbatim}

~/src/simple_maths$ t4db
sqlite> update b set out=23 where id=2;
sqlite> update c set out=46 where id=3;
sqlite> update object set need_reload=1 where id in ( 2, 3 );
~/src/simple_maths$ send_reload.sh
\end{verbatim}

This produces the following output:

\begin{verbatim}
Tier 1 running.
calculate_b( b )
calculate_c( c )
Tier 1 ran 2 objects in 7.29561e-05 seconds.

Tier 2 running.
calculate_x( x )
calculate_y( y )
Tier 2 ran 2 objects in 3.60012e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 1470
Tier 3 ran 1 objects in 2.69413e-05 seconds.
\end{verbatim}

From this you can see both b and c on T1 and x and y on T2 both run concurrently. 

If fact in this example they don't as we're running is single threaded mode to keep the output orderly, but this is easily set with the environment variable NUM_THREADS, e.g.:

\begin{verbatim}
~/src/simple_maths$ export NUM_THREADS=16
~/src/simple_maths$ simple_maths
\end{verbatim}

\chapter{Bond risk simple}

\section{Introduction}

Now we're going to examine a real world example of the trad4 architecture from the world of finance - bond_risk. This is a model that calculates the risk on two financial instruments - bonds and outright trades - that depend on the expected future values of interest rates. In this first chapter we'll be examining a cut-down version of the final app - bond_risk_simple, in fact a branch of bond_risk. In the next chapter we'll extend this model and examine how it handles under load.

First, the abstract graph:

\includegraphics[scale=0.5]{bondrisksimpleabstract.png}

\subsection{T1: ir_curve and calendar}

The first type on T1 is ir_curve. This contains information about the expected future value of interest rates. We observe information from the markets to obtain a set of input_rates, and construct a curve starting today and going forward to a set endpoint (say 10 years). This constructed curve has an entry for each day from today to 10 years containing information derived from our input rates, which will be consumed by the T2 bond objects. The key point to note about ir_curves is that they are expensive to construct - the various algorithms used to bootstrap and interpolate the various curves are computationally expensive.

There's a second type on T1 - the calendar, which gives today's date. Trad4 applications are designed to stay up during the week, and date rolls are handled by updating the calendar.

\subsection{T2: bond}

The second type on T2 is bond. A bond is a financial instrument that you buy for a certain price, and pays you fixed payments or coupons at a certain rate until it matures (say 5 years). Because it pays you money at a fixed rate (say 3\% per year), it will become more or less valuable depending on the current and expected future value of interest rates. A bond that pays 3\% when interest rates are 3% will be worth 100 (they are bought and sold in lots of 100), but it will have a higher price when interest rates are at 1\% (say 102.8) then when they are at 5\% (say 97.8) because they pay out more than that same £100 would in the bank (at 3%).

\subsection{T3: outright_trade}

The last type on T3 is outright_trade. This trade captures value of the purchase of a bond at a particular time. If you buy a bond with a price of £100 today, and the bond price rises in the future because interest rates fall, the present value (pv) of that trade increases. If you sell the bond at that future time you stand to make a profit. This profit or loss (pnl) is calculated by the original price of the bond and the bond's current published price.

\subsection{Risk: pv01}

In addition to bond's price and outright_trade's pv and pnl, there are other risk measures we can produce for these types, and in this example we're going to focus on is pv01. The pv01 of a bond is the amount the price or present value (pv) will change given a small shift - 1 basis point (bp - 100th of a percent) - in interest rates. If a bond has a high pv01 it's price is likely to be very sensitive to interest rate movements and be inherently more risky. A bond with a low pv01 will be less sensitive to interest rates. 

Likewise an outright_trade on a bond with a high pv01 will itself be sensitive to the volatility of the bond, so it will have an indirect sensitivity to interest rates.

The way pv01 is calculated is that the ir_curve is bumped or perturbed up by 1bp and the bond is priced against that perturbed curve. Then then original ir_curve is bumped down by 1bp and again the bond is priced. The difference between these two prices is the pv01.

From the perspective of the trad4 architecture this is quite easy to achieve: We just have the ir_curve type also produce bootstrapped curves perturbed up and down by 1bp. Then bond can read the bumped and un-bumped forward rates directly from the ir_curve objects. 

\section{The Concrete Graph}

In Section ~\ref{sec:The data} the distinction between types and objects was made. This becomes clearer now as in this data set we will have two ir_curves, five bonds and nine outright_trades. These objects - instantiated types - are shown on the concrete graph represented by ovals containing the object name. This is shown below:

\includegraphics[scale=0.25]{bondrisksimpleconcrete.png}

From this we can see the two ir_curves in two different currencies LIBOR.USD and LIBOR.GBP on T1. Then we can see the five bonds on T2, two of which were issued in USD (prefixed with US) which subscribe to LIBOR.USD, and three of which were issued in GBP (prefixed with UK) which subscribe to LIBOR.GBP. Lastly we have the nine outright_trades (their trade ticket numbers prefixed with O for outright)) which subscribe to various bonds.

\section{The t4s files}

The bond_risk application uses some more advanced features of trad4, specifically constants, enums, aliases and structures. These will be introduced in the next section and expanded on in section ~\ref{sec:Language Features}. Additionally ir_curve uses array members, which will be discussed in that section.

The t4s files are the trad4 system files that you supply as you need the relevant features. They described below.

\subsection{constants.t4s}

The constants.t4s file allows you to define your own constants that will be in scope in all calculate functions. Below, bond_risk's constants.t4s file:


\begin{verbatim}
NUM_FORWARD_DAYS = 7305  # 10 years

NUM_INPUT_RATES = 10

YEAR_BASIS = 365.25
\end{verbatim}

This describes the start and end dates covered by this model, and the number of forward dates are calculated from that data. Also the number of input_rates is set here, as is the year basis which describes how years are calculated.

\subsection{enums.t4s}

You can define your own enums to use in the t4 files in src/enums.t4s. There's only one enum used in bond_risk, used to indicate the direction of a trade:

\begin{verbatim}
buy_sell_enum
    BUY
    SELL
\end{verbatim}

\subsection{aliases.t4s}

Aliases are simply typedefs, used to clarify your t4 files and structures:

\begin{verbatim}
date = long int
\end{verbatim}

\subsection{structures.t4s}

Any structures you require in your t4 files can be described in structures.t4s. Again there's only one structure used in bond_risk, and that's a rate, described by a value on a particular date (the date given in aliases.t4s):

\begin{verbatim}
rate
    double value
    int days_forward
\end{verbatim}

Given the above definitions, we can now tackle bond_risk's t4 files. We will look at each type in turn.

\section{ir_curve}

\subsection{The t4 files}

The t4 files are divided into three different sections (all of them optional) - there's the sub section, which lists the other types to which this type subscribes, the static section which is driven by the object's database tables, and the pub section where the results of the calculations using it's static and the pub and static sections of the objects to which it subscribes. These will be discussed in more detail below.

\begin{verbatim}
static
    rate input_rates[NUM_INPUT_RATES]

pub
    double interest_rate_interpol[NUM_FORWARD_DAYS]
    double discount_rate[NUM_FORWARD_DAYS]
    double discount_rate_p01[NUM_FORWARD_DAYS]
    double discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

\subsubsection{The static section}

The static section is populated from the object's database tables. This data is loaded when the object starts, and may be reloaded at run-time. The static section is published to the rest of the world, but it's not touched by the calculate function.

In this section above we can just see the input_rates, which are an array of rates - the structure defined above - of length NUM_INPUT_RATES as defined in constants.. This is an input to our model, as we're going to move interest rates up and down to see how our bond's and trade's price and risk respond. 

\subsubsection{The pub section}

The pub section is where the results of the object's calculate function are published to the rest of the world. The variables in this section are zeroed when the object starts, and are used as intermediate and final results in the calculate function. If you add a variable to the pub section you will not need to modify the database.

In this section we have four arrays of doubles of length NUM_FORWARD_DAYS. The interest_rate_interpol array is used to store the interpolated input_rates. The other three arrays store the discount_rate - calculated form the interpolated input_rates, and the discount_rate perturbed up and down by one basis point ( _p01 and _m01 respectively). This will be used by other objects to calculate their risk as described below.

\subsection{The calculate function}

\subsubsection{The static section}

This static data is available in the calculate function using the provided macros:

\begin{verbatim}
static:
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    date ir_curve_input_rates_asof( NUM_INPUT_RATES )
\end{verbatim}

Given NUM_INPUT_RATES=10, you can use these macros to access the static data in your calculate function as follows:

\begin{verbatim}
    // Get a copy of the first rate
    rate start_rate = ir_curve_input_rates[0];
    // Get a copy of the last rate
    rate end_rate = ir_curve_input_rates[NUM_INPUT_RATES-1];

    // Output the asof date and rate of the start_rate
    cout << "start_rate.asof: " << start_rate.asof << endl;
    cout << "start_rate.value: " << start_rate.value << endl;

    // Loop thought the input rates, outputting the rate and date.
    for ( int i = 0 ; i < NUM_INPUT_RATES ; i++ )
    {
        cout << ir_curve_input_rates_asof( i ) << endl;
        cout << ir_curve_input_rates_value( i ) << endl;
    }
\end{verbatim}

For those financial professionals among you I should make clear that these input_rates contain the bootstrapped forward rates as I've avoided including a bootstrapper to keep things simple. These rates still require interpolation at a daily granularity and conversion into discount factors.

\subsubsection{The pub section}

The pub section is where the results of the object's calculate function are published to the rest of the world. The variables in this section are zeroed when the object starts, and are used as intermediate and final results in the calculate function. If you add a variable to the pub section you will not need to modify the database.  

In this section we have four arrays of doubles of length NUM_FORWARD_DAYS. The interest_rate_interpol array is used to store the interpolated input_rates. The other three arrays store the discount_rate - calculated form the interpolated input_rates, and the discount_rate perturbed up and down by one basis point ( _p01 and _m01 respectively). This will be used by other objects to calculate their risk as described below. 

This pub data can be written to within the calculate function using the provided macros:
\begin{verbatim}
pub:
    double ir_curve_interest_rate_interpol[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_p01[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

Given NUM_FORWARD_DAYS = END_DATE - TODAY, you can use these macros in your calculate function as follows:

\begin{verbatim}
    // Calculate the interpolated rate
    // For details please see bond_risk/objects/ir_curve.c
    ir_curve_interest_rate_interpol[i] = ( i*gradient + y_intercept );

    // Calculate the discount factor, plus the two perturbed discount factors
    for ( int i = 0 ; i < NUM_FORWARD_DAYS ; i++ )
    {
        num_years = i / YEAR_BASIS;

        ir_curve_discount_rate[i] = 
            exp( -ir_curve_interest_rate_interpol[i] * num_years );
        ir_curve_discount_rate_p01[i] = 
            exp( -(ir_curve_interest_rate_interpol[i] +0.0001) * num_years );
        ir_curve_discount_rate_m01[i] = 
            exp( -(ir_curve_interest_rate_interpol[i] -0.0001) * num_years );
    }
\end{verbatim}

\section{bond}

\subsection{The t4 files}

\begin{verbatim}
sub
    calendar calendar
    ir_curve ir_curve

static
    date start_date
    date maturity_date
    int coupons_per_year
    double coupon

pub
    double price
    double pv01
\end{verbatim}

\subsubsection{The sub section}

In the sub section, we can see that bond subscribes to an ir_curve and a calendar object.

\subsubsection{The static section}

In the static section we can see the static data that makes up a simple bond. They have a start_date, the date the bond was issued and is some time in the past. They have a maturity_date when the bond matures - ceases paying out and pays back the 100 you could have bought for at par. The coupons_per_year member describes how often the bond pays, so coupons_per_year=1 pays out once a year and coupons_per_year=4 pays out every quarter. Lastly there's the coupon, which is the rate at which it pays each coupon (e.g. 3% pa).

\subsubsection{The pub section}

The pub section is where the results of bond's calculate function are stored and published. There is the bond's price, calculated form the bond's static and ir_curve's pub section, and pv01 which uses the _p01 and _m01 sections of ir_curve.

\subsection{The calculate function}

\subsubsection{The sub section}

The sub macros available in bond's calculate function pull all the pub and static sections of ir_curve into the scope of the function (from gen/objects/bond_macros.h):

\begin{verbatim}
sub:
    id bond_calendar
    date calendar_today

    id bond_ir_curve
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    int ir_curve_input_rates_days_forward( NUM_INPUT_RATES )
    double ir_curve_interest_rate_interpol[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_p01[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

We can use these in the calculate function as follows:

\begin{verbatim}
    // Get the discount_rate from ir_curve
    double discount_rate = ir_curve_discount_rate[ir_offset];
\end{verbatim}

\subsubsection{The static section}

The macros for the static section look like this:


\begin{verbatim}
static:
    int bond_start_date
    int bond_maturity_date
    int bond_coupons_per_year
    double bond_coupon
\end{verbatim}

These can be used in the calculate function as follows:

\begin{verbatim}

    double coupon_rate_per_period = bond_coupon / bond_coupons_per_year;

\end{verbatim}


\subsubsection{The pub section}

The pub section macros are as follows:

\begin{verbatim}
pub:
    double bond_price
    double bond_pv01

\end{verbatim}

Which can be assigned to as follows:

\begin{verbatim}
    // Use the discount_rate to discount the future coupon payments and sum
    bond_price = bond_price + 
        ( 100.0 * coupon_rate_per_period * discount_rate );
\end{verbatim}

\section{outright_trade}

The outright_trade's t4 file is as follows:

\begin{verbatim}
sub
    bond bond

static
    double trade_price
    int quantity
    date trade_date
    buy_sell_enum buy_sell

pub
    double pv
    double pv_01
    double pnl
\end{verbatim}

From this we can see that outright_trade subscribes to a bond. In the static section we can see it has a trade_price - the price at which these bonds were purchased, the quantity of bonds purchased and the date of the transaction. The direction of the trade - whether the trade was a buy or a sell of the bonds.

The macros look like this:

\begin{verbatim}
sub:
    id outright_trade_bond
    date bond_start_date
    date bond_maturity_date
    int bond_coupons_per_year
    double bond_coupon
    double bond_price
    double bond_pv01

static:
    double outright_trade_trade_price
    int outright_trade_book
    int outright_trade_quantity
    date outright_trade_trade_date

pub:
    double outright_trade_pv
    double outright_trade_pv_01
    double outright_trade_pnl
\end{verbatim}

The calculate function for outright_trade is shown below in full.

\begin{verbatim}
int calculate_outright_trade( obj_loc_t obj_loc, long id )
{
    // Get multiplier for trade direction.
    double direction = ( outright_trade_buy_sell == BUY ? 1.0 : -1.0 );

    // Calculate the pv - the present value of the trade.
    outright_trade_pv = ( outright_trade_quantity * bond_price ) * direction;

    // Calculate the pv01 - the pv's exposure to interest rate movements.
    outright_trade_pv_01 = 
        ( outright_trade_quantity * bond_pv01 ) * direction;

    // Calculate the pnl - the profit or loss we would make on the trade if we 
    // re-sold these bonds today.
    outright_trade_pnl = outright_trade_pv - 
        ( outright_trade_quantity * outright_trade_trade_price ) * direction;

    return 1;
}
\end{verbatim}

\section{Operation}

We'll now run the application, first using data/worked_example with log_level=1 for the ir_curve (as it publishes arrays so the debug is verbose), and log_level=2 for the rest of the objects, which will output the static and pub data for each object.

\subsection{worked_example}
 
\begin{verbatim}
$ rt4
Creating new type bond, type_id: 3
Creating new type outright_trade, type_id: 4
Creating new type ir_curve, type_id: 2
Creating new type calendar, type_id: 1
Loading objects...
Loading bond..
Loading outright_trade..
Loading ir_curve..
        load_ir_curve_input_rates()
Loading calendar..

\end{verbatim}

First you can see the types being created and the objects being loaded. As we're using data/worked_example there's only

\begin{verbatim}
Validating objects...

Num objects on T1: 2
Num objects on T2: 1
Num objects on T3: 1

Running in single-threaded mode.
\end{verbatim}

Next, the objects are validated and a report produced on how many objects are on each tier. As we're using data/worked_example there's one object per type. 

Lastly the number of threads being used for this run is reported.

\begin{verbatim}
Tier 1 running.
calculate_calendar( calendar )
static:
    calendar_today: 40403
pub:

calculate_ir_curve( LIBOR-GBP )
Tier 1 ran 2 objects in 0.00102782 seconds.
\end{verbatim}

Text, T1 runs. The first object is the singleton calendar object, which just publishes the valuation date - 13th August 2010\footnote{More or less, depending on your view on leap years...} in julian format.

The next object is the ir_curve, which calculates and interpolates the discount factors as discussed above.

\begin{verbatim}
Tier 2 running.
calculate_bond( US81823453 )
static:
    bond_start_date: 39814
    bond_maturity_date: 43467
    bond_coupons_per_year: 1
    bond_coupon: 0.028
pub:
    bond_price: 105.177
    bond_pv01: -0.0787914

Tier 2 ran 1 objects in 5.79357e-05 seconds.
\end{verbatim}

Next, the bond on T2 runs. You can see it output it's static data it's got from the database, and the pub data that it's calculated and published, derived from the calendar and ir_curve objects it subscribes to.

\begin{verbatim}
Tier 3 running.
calculate_outright_trade( O38273 )
static:
    outright_trade_trade_price: 104.7
    outright_trade_quantity: 1000
    outright_trade_trade_date: 40323
    outright_trade_buy_sell: 0
pub:
    outright_trade_pv: 105177
    outright_trade_pv_01: -78.7914
    outright_trade_pnl: 476.868

Tier 3 ran 1 objects in 2.69413e-05 seconds.

All tiers ran 4 objects in 0.00114417 seconds.

Exiting after first run as BATCH_MODE is set.
\end{verbatim}

Lastly the outright_trade on T3 runs, and again you can see both it's static and pub data, and the total time for all tiers displayed. Lastly, the application exits as the environment variable BATCH_MODE is set.

Next, we'll run the application with data/small_set and log_level=1 for all objects.

\subsection{small_set}

\begin{verbatim}
Tier 1 running.
calculate_calendar( calendar )
calculate_ir_curve( LIBOR.USD )
calculate_ir_curve( LIBOR.GBP )
Tier 1 ran 3 objects in 0.00203395 seconds.

Tier 2 running.
calculate_bond( UK312894725 )
calculate_bond( UK298671424 )
calculate_bond( UK34158410 )
calculate_bond( US235632480 )
calculate_bond( US915766195 )
Tier 2 ran 5 objects in 8.39233e-05 seconds.

Tier 3 running.
calculate_outright_trade( 0218847 )
calculate_outright_trade( 0331682 )
calculate_outright_trade( 0921660 )
calculate_outright_trade( 0481677 )
calculate_outright_trade( 0897310 )
calculate_outright_trade( 0122687 )
calculate_outright_trade( 0609115 )
calculate_outright_trade( 0755361 )
calculate_outright_trade( 0372878 )
Tier 3 ran 9 objects in 2.21729e-05 seconds.
\end{verbatim}

In this case all the objects on each tier will run concurrently, given enough threads.

TODO: BATCH_MODE off, updates and bump_interest_rates.sh

\chapter{Bond risk}

\section{Introduction}

In this chapter we'll extend the model by introducing repo_trades and books - collections of trades. The types ir_curve, calendar, bond and outright_trade behave as before.

Below, the abstract graph for the enhanced model:

\includegraphics[scale=0.5]{bondriskabstract.png} 

\section{repo_trade}

An understanding of the repo_trade is not vital to the rest of this document, so if you choose to skip this section suffice to say a repo_trade is another type which is more computationally expensive than an outright_trade, with a dependency on ir_curve, calender and bond. 

A repo trade is a kind of secured loan, used by investments banks to raise cash. They are sitting on a pile of bonds they have bought, so they can lend these out in exchange for cash collateral which the banks then use for funding. So they have a start date, and end date and a rate at which interest is calculated on the cash.

Repo trades also need the bond price to calculate their margin, plus a discount rate curve with which to 
calculate the mark-to-market profit and loss (mtm_pnl) - which is a measure of how much cheaper it was to raise this cash using the repo trade than it would have been to borrow on the open markets.

Repo trades also have a margin, which is part of the settlement details of a repo trade and sets the amount of collateral held with a third-party clearing house. It's the difference between the cash we borrowed and the value of the bond collateral - if our margin drops below a certain level we may have to make a margin payment to top up the collateral.

The .t4 files and calculate functions can be found in the source distribution, as there's nothing in there you haven't seen already. 

\section{The books}

Trades are grouped into books (a.k.a portfolios), so all your outright_trades against US-issued bonds might be kept in a book called OUTRIGHT_USD and your UK-issued ones in a book called OUTRIGHT_GBP. These books aggregate your risk so you can see overall exposure to particular market force (e.g. US interest rates). There is a book type for each trade type, which gives outright_book and repo_book.


\subsection{The .t4 files}

The books subscribe to multiple objects of the same type. This is done in the .t4 as shown below (from bond_risk/src/outright_book.t4):

\begin{verbatim}
sub
    outright_trade outright_trades[MAX_TRADES_PER_BOOK]

pub
    double pv
    double pv_01
    double pnl
\end{verbatim}

The sub section shows the syntax for sub arrays. This array will contain the id's of all the outright_trades to which this object subscribes. You'll notice the pub section has the same profile as the outright_trades.

A new constant has also been introduced - MAX_TRADES_PER_BOOK. Set to 10 in this document to keep the code blocks small, but will be set larger when testing under load.

\subsection{The calculate function}

The way this works in the calculate section is as follows. The sub macros look like this:

\begin{verbatim}
sub:
    id outright_book_outright_trades[MAX_TRADES_PER_BOOK]
    double outright_trades_trade_price( MAX_TRADES_PER_BOOK )
    int outright_trades_quantity( MAX_TRADES_PER_BOOK )
    date outright_trades_trade_date( MAX_TRADES_PER_BOOK )
    buy_sell_enum outright_trades_buy_sell( MAX_TRADES_PER_BOOK )
    double outright_trades_pv( MAX_TRADES_PER_BOOK )
    double outright_trades_pv_01( MAX_TRADES_PER_BOOK )
    double outright_trades_pnl( MAX_TRADES_PER_BOOK )
\end{verbatim}

The first five macros offer up the static data for each object, with the last three the pub data.

It's important to note that the index used as an argument to these macros isn't the sub object's id - it's the index into the array of outright_trades. The other thing to note is that the array need not be fully populated - in which case the id at that index is set to 0. Given this, this works as follows (from bond_risk/objects/outright_book.c):

\begin{verbatim}
int calculate_outright_book( obj_loc_t obj_loc, long id )
{
    // Reset the accumulators
    outright_book_pv=0;
    outright_book_pv_01=0;
    outright_book_pnl=0;

    // Note the counter from 0 to < MAX_TRADES_PER_BOOK
    for ( int i=0 ; i < MAX_TRADES_PER_BOOK ; i++ )
    {
        // Note the test to see if this objects exists before de-referencing
        if ( outright_book_outright_trades[i] )
        {
            outright_book_pv += outright_trades_pv(i);
            outright_book_pv_01 += outright_trades_pv_01(i);
            outright_book_pnl += outright_trades_pnl(i);
        }
    }

    return 1;
}
\end{verbatim}

\subsection{The database}

The database structure for outright_book is similar to what we've seen before - each object has a row in the object and outright_book tables, but is also has a row in outright_book_outright_trades, the structure of which is as follows (from bond_risk/gen/sql/outright_book_outright_trades.table):


\begin{verbatim}
create table outright_book_outright_trades (
    id int,
    col0 int,
    col1 int,
    col2 int,
    col3 int,
    col4 int,
    col5 int,
    col6 int,
    col7 int,
    col8 int,
    col9 int
);
\end{verbatim}

The data in worked_example looks like this (from bond_risk/data/worked_example/outright_book_outright_trades.sql):

\begin{verbatim}
insert into outright_book_outright_trades values ( 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
\end{verbatim}

In this case, there's only one trade (id = 4) subscribed to by this book (id = 6), as there's only a single outright_trade in this data set. We'll ramp up the data set sizes in the next section.

\section{Operation under load}

For now please see the section on-line: http://trad4.sourceforge.net/bond_risk/analysis.html

\chapter{Language Features}
\label{sec:Language Features}


In this section we'll be discussing some of the features of trad4 in detail. This is intended to serve a reference, but a read through is suggested.

\section{Constants}

Any application-wide constants can be defined in src/constants.t4s. Anything to the right of a hash is considered a comment and discarded. Constants can also be defined in terms of other constants, and scientific notation is supported. Below, some examples from various trad4 applications.

\begin{verbatim}
YEAR_BASIS = 365.25     # Number of days in a year

SAMPLE_RATE=44100
NYQUIST_FREQUENCY = SAMPLE_RATE / 2.0

NUM_BODIES=2
NUM_OTHER_BODIES=NUM_BODIES-1
G=6.673e-11

\end{verbatim}

Be aware that these will be evaluated by the precompiler. If they are not completely described, the precompiler will throw an error.

\section{Enums}


Enums can be defined in src/enums.t4s, e.g.:
\begin{verbatim}
buy_sell_enum
    BUY
    SELL
\end{verbatim}

These will then be available as types within your .t4 file, e.g.:

\begin{verbatim}
static
    buy_sell_enum buy_sell
\end{verbatim}


And then dereferenced in your calculate function with the usual notation:
\begin{verbatim}
    if ( repo_trade_buy_sell == BUY ) 
\end{verbatim}

These will be represented in the database as integers.

\section{Aliases}

Aliases are just typedefs, and can be defined in src/aliases.t4,s e.g.:

\begin{verbatim}
boolean = int
date = long int
\begin{verbatim}

These will then be available as types within your .t4 file, e.g.:

\begin{verbatim}
static
    date start_date
\end{verbatim}




\section{Structures}

Structures can be defined in src/structures.t4s:

\begin{verbatim}
rate
    double value
    int asof
\end{verbatim}

These will then be available as types within your .t4 file, e.g.:

\begin{verbatim}
static
    rate ir_rate
\end{verbatim}

These structures are expanded in the macros:

\begin{verbatim}
static:
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    date ir_curve_input_rates_asof( NUM_INPUT_RATES )
\end{verbatim}

So ir_curve_input_rates is an array of rate structures, but ir_curve_input_rates_value and ir_curve_input_rates_asof are function-like macros and return the actual rate or date the rate you're interested in, given it's offset. For example:

\begin{verbatim}
    // Get a copy of the first rate
    rate start_rate = ir_curve_input_rates[0];

    // Output the asof date and rate of the start_rate
    cout << "start_rate.asof: " << start_rate.asof << endl;

    // Loop thought the input rates, outputting the rate and date.
    for ( int i = 0 ; i < NUM_INPUT_RATES ; i++ )
    {
        cout << ir_curve_input_rates_asof( i ) << endl;
        cout << ir_curve_input_rates_value( i ) << endl;
    }
\end{verbatim}


Static structures are stored on their own DB tables, so that, assuming that the rate structure above is used in object ir_curve.t4, the associated database table would look like:

\begin{verbatim}
create table ir_curve_input_rates (
    id int,
    ord1 int,
    value float,
    asof int
);
\end{verbatim}

The id is the unique id of the object that these input_rates refer to. The ord1 column is the index of the rate, so that ord1=0 would be the first rate and ord1=NUM_INPUT_RATES-1 the last. The value and asof columns hold the actual data. So our data might look like:

\begin {tabular} {| l | l | l | l |}
\hline
id & ord1 & value & asof \\
\hline
1 & 0 & 0.024 & 40403 \\
\hline
1 & 1 & 0.025 & 40590 \\
\hline
1 & 2 & 0.026 & 40773 \\
\hline
1 & 3 & 0.025 & 41138 \\
\hline
1 & 4 & 0.025 & 41868 \\
\hline
1 & 5 & 0.024 & 42598 \\
\hline
1 & 6 & 0.023 & 43328 \\
\hline
1 & 7 & 0.023 & 44058 \\
\hline
1 & 8 & 0.022 & 45883 \\
\hline
1 & 9 & 0.022 & 47708 \\
\hline
\end {tabular}

See the next chapter for details on how arrays of structures and nested structures are handled.




\section{Arrays}

Arrays in the t4 file are treated differently depending on whether they appear in the pub, static (which are both treated the same) or sub sections. 

\subsection{Static and pub Arrays}

Arrays in the static and pub section work as you'd expect, using any constants you defined above. E.g., in your .t4 file (from test_app/src/tier1.t4):

\begin{verbatim}
static
    double double_array[10]
\end{verbatim}

The macros for these look as you'd expect:

\begin{verbatim}
static:
    double tier1_double_array[10]
\end{verbatim}

These can be used in your calculate function as follows:

\begin{verbatim}
    cout << tier1_double_array[0] << endl;   // Output first double
    cout << tier1_double_array[9] << endl;   // Output last double
\end{verbatim}

Any static arrays also need to persist in the database, and again the table structure is generated for you 
by trad4. The database table will look like:

\begin{verbatim}
create table tier1_double_array (
    id int,
    col0 int,
    col1 int,
    col2 int,
    col3 int,
    col4 int,
    col5 int,
    col6 int,
    col7 int,
    col8 int,
    col9 int
);
\end{verbatim}

So in this case the data for double_array is laid out in columns, so our data looks like this:


\begin {tabular} {| l | l | l | l | l | l | l | l | l | l | l |}
\hline
id & col0 & col1 & col2 & col3 & col4 & col5 & col6 & col7 & col8 & col9 \\
\hline
1 & 0.14 & 1.14 & 2.14 & 3.14 & 4.14 & 5.14 & 6.14 & 7.14 & 8.14 & 9.14 \\
\hline
\end {tabular}


\subsection{Sub Arrays}

Arrays of sub objects look similar to the static and pub arrays in the t4 file, but the macros are more complex. From bond_risk, outright_book:

\begin{verbatim}
sub
    outright_trade outright_trades[MAX_TRADES_PER_BOOK]
\end{verbatim}

The macros give full access to the sub objects, but with an extra parameter to identify their index.

\begin{verbatim}
sub:
    id outright_book_outright_trades[MAX_TRADES_PER_BOOK]
    int outright_trades_quantity( MAX_TRADES_PER_BOOK )
    double outright_trades_pv( MAX_TRADES_PER_BOOK )
\end{verbatim}

Which can be used in your calculate function as follows:

\begin{verbatim}
    double sum_pv(0.0);
    
    for ( int i=0 ; i < MAX_TRADES_PER_BOOK ; i++ )
    {
        if ( outright_book_outright_trades[i] )
        {
            sum_pv += outright_trades_pv(i);
        }
    }

    cout << "sum_pv: " << sum_pv << endl;
\end{verbatim}

You'll note from the above that the array can have empty elements - just set these to 0 and test for them before you dereference.

TODO: DB

If the sub object has structures or arrays of it's own, then this is also handled. Take a simplified example of additive_synth, where a mixer subscribes to a number of samples, and those samples contain an array of ints - a sampled waveform. The the t4 files look like this:


\begin{verbatim}
sample.t4:

pub
    int wave[SAMPLE_COUNT]

mixer.t4:

sub
    sample samples[NUM_HARMONICS_PER_MIXER]

pub
    int wave[SAMPLE_COUNT]
\end{verbatim}

The macros for mixer then look like this:

\begin{verbatim}
sub:
    id mixer_samples[NUM_HARMONICS_PER_MIXER]
    int samples_wave( NUM_HARMONICS_PER_MIXER, SAMPLE_COUNT )

pub:
    int mixer_wave[SAMPLE_COUNT]
\end{verbatim}

As you can see, as with the above example you can access the underlying wave using the offset of the sub object, combined with the index into that sample's wave. These can be used in your calculate function as follows:

\begin{verbatim}
    for ( int j = 0 ; j < NUM_HARMONICS_PER_MIXER ; j++ )
    {
        if ( mixer_samples[j] )
        {
            for ( int i = 0 ; i < SAMPLE_COUNT ; i++ )
            {
                mixer_wave[i] += samples_wave( j, i );
            }
        }
    }
\end{verbatim}

\chapter{Further Language Features}

\section{Inheritance of Interface}

Inheritance of interface was introduced to solve a particular problem where you don't know the types of the objects that you will be subscribing to at run-time. Take the following example from simple_maths:

\begin{math}
  \begin{array}{ l c }
        & z = x * y   \\
        where         \\
        & x = a + b   \\
        & y = c - d   \\
        and           \\
        & a = 7       \\
        & b = 14      \\
        & c = 27      \\
        & d = 11      \\
  \end{array}
\end{math}

And the abstract graph is as follows:

\includegraphics[scale=0.5]{simplemathsabstract.png}

Now the problem with this arrangement is that type x is hard-coded in x.t4 to only subscribe to types a and b, and sum the two. Likewise z is hard-coded to only subscribe to types x and y, and multiply the two. This means the system is not configurable - the behaviour of the system is hard coded in the t4 files.

What we need to be able to do is allow any operation to subscribe to any other operation, so we can configure the behaviour at run-time. The answer to this is inheritance of interface (IoI), which is demonstrated by the trad4 application general_computer.

\subsection{general_computer}

The plan is to create a series of objects that perform primitive mathematical functions - plus, minus, natural_log, cume_norm_dist etc., and configure the relationship between these objects to solve a particular problem. The interesting thing about this approach is that once we've created the application, we can configure the relationship between the objects at run-time by manipulating data in the database. 

Below, the concrete diagram for the data set worked_example. You'll notice we've switched from the abstract diagram of simple_maths (which shows the hard-coded types) to the concrete diagram of general_computer (which shows the relationship between the running objects), but the functionality remains the same. This frees us of the hard-coded limitations discussed above.

\includegraphics[scale=0.5]{generalcomputerworkedexample.png}

What we do is create a base type 'numeric' (analogous to a pure virtual base class in C++) that every other type inherits the interface (i.e. the pub section) of. In this way, an 'addition' type could subscribe to a 'multiplication' type or another addition type, as both \emph{isa} numeric.

\subsubsection{The t4 files}

The base type numeric is defined as follows (from general_computer/src/numeric.t4):

\begin{verbatim}
pub
    double output
\end{verbatim}

The only member numeric has is a double called output in the pub section. This is the only thing every other numeric has in common - they all produce an output.

Now let's take a look at addition.t4:

\begin{verbatim}
sub
    numeric numeric1
    numeric numeric2

implements numeric
\end{verbatim}

This type subscribes to two numerics and implements numeric (i.e. inherited the pub member output). The t4 files for the rest of the binary (two-inputs) types like multiplication etc. look the same, as they all subscribe to two numerics and perform an operation on them.

The unary types (natural_log, square_root etc.) only have one input:

\begin{verbatim}
sub
    numeric numeric

implements numeric
\end{verbatim}

The feeds - the way we're feeding numbers into whatever system we configure - don't subscribe to any types but do have a static section where the data from the database is published:


\begin{verbatim}
static
    double value

implements numeric
\end{verbatim}

The abstract diagram for the cut-down set of operators we need for the above example from simple_maths is shown below:

\includegraphics[scale=0.4]{generalcomputerabstractsimple.png}

This shows a feed that exist on any tier, the binary operators which must subscribe to two objects on a tier below them, and the bast type numeric.

\subsubsection{The calculate function}

The calculate functions work as usual. So for example a binary function (general_computer/objects/addition.c):

\begin{verbatim}
int calculate_addition( obj_loc_t obj_loc, long id )
{
    addition_output = numeric1_output + numeric2_output;

    return 1;
}
\end{verbatim}

A unary function (general_computer/objects/natural_log.c):

\begin{verbatim}
int calculate_natural_log( obj_loc_t obj_loc, long id )
{
    natural_log_output = log( numeric_output );

    return 1;
}
\end{verbatim}

And the feed, which just copies the static data to it's output (general_computer/objects/feed.c):

\begin{verbatim}
int calculate_feed( obj_loc_t obj_loc, long id )
{
    feed_output = feed_value;

    return 1;
}
\end{verbatim}









\chapter{New Application Walk-through}

\section{Run create_new_app.sh}

Change directory into trad4's bin directory and run the script, giving your new app name as the argument.

\begin{verbatim}
    trad4/bin$ ./create_new_app.sh <app_name>
\end{verbatim}

This will create the directory structure for your new application, plus a couple of files you'll be needing.

For the rest of this chapter substitute simple_maths for your application, or follow along with a downloaded  distribution of simple_maths.

\section{Source your .conf file}

You should always source the relevant .conf file at the beginning of each session to set the environment  up:

\begin{verbatim}
simple_maths$ . ./simple_maths.conf
\end{verbatim}

\section{Write your .t4 files}

Set out the sub, static and pub sections. For example, the .t4 file for the type 'a' from simple_maths is:

\begin{verbatim}
static
    int out
\end{verbatim}

As you can see, this type just has a single static variable of type int. This is loaded when the object is started and doesn't change unless it reloads a new value from the database.

The .t4 file for the type 'x' from simple_maths is:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Type x has a sub section, describing the type and name of the objects to which it subscribes. In this case it's a type a as described above and a type b (not shown, but identical to a.t4). There is one variable in the pub section this is where x publishes it's output value, called 'out' of type int.

The sub types in the .t4 files must always be of another trad4 type. The static and pub types can be of the following built-in C++ types:

\begin{itemize}
\item int
\item char
\item float
\item double
\item long
\end{itemize}

Arrays are supported in the sub, static and pub sections. Also, constants, enums, aliases and structures can be defined and also used in the static and pub sections. More on this later.

\section{Edit your object_types.t4s file}

This file contains an entry for each type:
\begin{verbatim}
#type_id, tier, name
1,1,a
2,1,b
3,1,c
4,1,b
5,2,x
6,2,y
7,3,z
\end{verbatim}

Each type must have it's own unique type_id, it's tier must be specified and it's name must be unique. 
Anything to the right of a hash will be considered a comment and ignored.

In this case there are seven types. The T1 types are a,b,c and d. There are two T2 types x and y, and one T3 type z.

\section{Run the trad4 precompiler}

The precompiler - precomp.pl - is aliased to 't4p':

\begin{verbatim}
    $ t4p
\end{verbatim}

This will create several files under your root directory, the most important of which to you are the files under simple_maths/objects. These files - one per object - contain the stub calculate functions that you must provide the logic for.  You could supply this functionality now, or if you're impatient you can skip to the next step and supply the functionality later.

A generated file you will be needing are the macros under simple_maths/gen/objects and have the file name $<$type$>$_macro.h. There's a comment at the top of this file that shows you what's in scope for the calculate function.

Also generated by the precompiler are the .table files that specify the default database structure. These are found under simple_maths/gen/sql. There is even some dummy data created under simple_maths/data/dummy_data.

The rest of the files produced by the precompiler provide the guts of the trad4 application and you will probably not be interested in. They reside with the macros under simple_maths/gen/objects.

The precompiler supports various command-line options, e.g.:

\begin{verbatim}
simple_maths]$ t4p -h
Usage: precomp.pl [OPTION]
The trad4 precompiler.

  -o <object>    precompile <object> only
  -k             continue on error
  -c             remove all generated files
  -a             remove all generated files and regenerate
  -v             verbose - dumps internal structures
  -d             generate documentation
  -h             display this help and exit
\end{verbatim}

\section{Choose how many threads you need}

To set the number of threads used you set the NUM_THREADS environment variable.

\begin{verbatim}
    $ export NUM_THREADS=16
\end{verbatim}

The default for a new application is 0, which means the master thread does all the work. Setting NUM_THREADS=1 means there is one master thread and one worker thread. The maximum is 4096.

As with all the environment variables, they can be set in app.conf file.


\section{Create the database}

Trad4 uses sqlite, a server-less flat file database. The structure is generated for you by the precompiler, as is some dummy data to get you started.

\begin{verbatim}
    $ recreate_db.sh
\end{verbatim}

This will load the table definitions generated under simple_maths/gen/sql into the DB, and (re)create the 
system tables.

Next, load the default data set:

\begin{verbatim}
    simple_maths/data$ reload_db.sh default_set/
\end{verbatim}

\section{Compile the application}

Note that the default_set will only work reliably if you haven't written your calculate functions yet, as the function may de-reference the dummy data and fail. The default_set is there as a guide to setting up your own data, and a way of getting up and running quickly.

To compile the application, just type make:

\begin{verbatim}
    simple_maths$ make
\end{verbatim}

This will compile and link your application and produce an executable binary of the same name as your 
application. You can run it now if you like. 

\begin{verbatim}
    simple_maths$ bin/simple_maths
\end{verbatim}

You should see the types being created, then the load functions being called and the objects being created (there's a one-to-one correspondence between the types and objects in the default_set). The objects are then validated and a short report is produced. The tiers are then run in turn and all the calculate functions being called, but they won't do anything yet as the logic hasn't yet been provided.

The application should then exit as BATCH_MODE is set as default, which caused the application to exit after the first run.

\section{The Calculate Function}

\section{The Object Data}

\section{Triggering an update}

To trigger an update you first need to set the need_reload flag on the object table to 1 for those objects you want to reload:

\begin{verbatim}
    SQL> update object set need_reload = 1 where id in (...);
\end{verbatim}

You'll then need to unset BATCH_MODE so that the application continues running. Then you send a signal to your application that there's one or more objects that need to be reloaded:

\begin{verbatim}
    $ send_reload.sh 
\end{verbatim}

You will then see all the objects triggering in the order you expect. All the calculate functions will be called, and you should see the affect of your update on the output.

Note that the dummy_data set created for you has need_reload=1 for all objects.

\section{Environment variables}
In this section some useful environment variables are listed. You can either export them locally from your shell or set them in your .conf file.

NUM_THREADS controls the number of worker threads used. The maximum is set to a rather unreasonable 4096. If you set it to 0 this will activate the single-threaded mode where the master thread runs the calculate function - useful for benchmarking, and stepping through the operation without getting a headache.

BATCH_MODE if set to 1 will terminate the application after the first run through. Useful during the early staged of development and benchmarking.

TIMING_DEBUG controls whether the tier-level timing is displayed. Generally you'll want it off  (0) if you're doing multiple iterations and on (1) if you're doing intensive calculations per-tier.

APP_DB points to the current sqlite .db file. The default is data/app_name.db

CXX gives the path to the g++ compiler

CC gives the path to the gcc compiler

CXXFLAGS contain the compilation flags. Default is "-Wall -fPIC -m32". Append with your own e.g. -O3, -g.

T4_3RD_PARTY_LIBS contains the space-separated full paths to any third-party shared libraries you're using, e.g. (from vision_thing) "\$APP_ROOT/lib/3rd_party/libjpeg.so \$APP_ROOT/lib/3rd_party/libgd.so". Don't forget to set LD_LIBRARY_PATH to pick these up at runtime.

T4_3RD_PARTY_AR contains the space-separated full paths to any third-party static libraries you're using, e.g. (from jpm_cds) "\$APP_ROOT/objects/isda_cds_model_c_v1.7/lib/build/lib/linux/cds.a"

T4_3RD_PARTY_HEADER_PATH contains the colon-separated paths to any third-party headers you need to include, e.g. "\$APP_ROOT/lib/3rd_party"

Note: If you change any of the compiler/linker environment variables above you should re-run the precompiler specifying -a (clean then precompile).

\section{Tips and Tricks}

\subsection{Keep it simple at first}

Keep it simple for now and restrict yourself to two or three types when you're starting a new application.

\subsection{The init flag}

There's an init flag available in the trad4 internals that is set if the object has fired once. It's useful for initialising certain kinds of objects, particularly in cyclic graphs. E.g. from heat_equation_1d, element.c:

\begin{verbatim}
    if ( ! object_init(id) )
    {
        element_x = (id*1.0)/NUM_NODES;
        element_y = cos( 2*(element_x) );
    }
    else
    {
        element_y = element_y + change_change;
    }
\end{verbatim}

\subsection{The STL is available}

The STL  can be used in your calculate functions, as long as you keep them on the stack. Just include the relevant headers at the top of your calculate function. The following example is from bond.c, and shows using a vector to hold the temporally generated coupon schedule:

\begin{verbatim}
#include <vector>

int calculate_bond( obj_loc_t obj_loc, long id )
{
    std::vector<date> coupon_schedule;
    coupon_schedule.push_back( bond_start_date );

    ...

    std::vector<date>::const_iterator iter = coupon_schedule.begin();

    for ( ; iter != coupon_schedule.end() ; iter++ )
    {
        ...
\end{verbatim}


\subsection{Catch and flag errors}

As discussed in the section on State Management, it's important that the user flags any problems in the calculate function if there's any danger that the pub data has been corrupted. This includes exceptions thrown by external libraries. If there's any doubt that the pub data has been corrupted just return 0 from the calculate function. For example:

\begin{verbatim}
int calculate_bond( obj_loc_t obj_loc, long id )
{
    try {

        ...

    }
    catch ( std::exception& e )
    {
        return 0;
    }

    return 1;
}
\end{verbatim}

You may well wonder why this error wasn't logged. The answer is, if you've got a million objects all running on the same host that subscribe to a single object (like a calendar) that goes bonkers, you don't want them all trying to write to stderr at the same time...



\subsection{Common functions}
It is possible to share code between heterogeneous objects. For example, you might require a function that interpolates curves in more than one object in your hierarchy. While there's no formal support for this in trad4 currently, there's nothing stopping you for defining your function in objects/my_func.c, and then doing a crafty:

\begin{verbatim}
#include "my_func.c"
\end{verbatim}

In each object's calculate file that needs it. Your function will have to be trad4-compliant, i.e. there should be no use of the heap etc. 

\subsection{The T4_TEST macro}

There's a macro defined in trad4.h that compares two numbers for closeness (to within 0.1). You can use it in your calculate function as follows:

\begin{verbatim}
T4_TEST( addition_output, 10.055 );
\end{verbatim}

It's useful for locking down the numbers while you make changes. It's specific to data sets so it's only really useful in development, but it's also used in test_app as there's only one data set.

\chapter{Library integration}

Firstly, in previous versions of this document I maintained that in order to use your existing application with trad4 you were looking at a port. \textbf{This is not the case} - you can call into your existing libraries although you might need some minor modifications.

Two different library use cases exist. The first case is when you need some service from a third-party library like writing to a .png (see vision_thing/create_animation), or writing a .wav file (see additive_synth/write_wav_file). In these cases we need to call into the library to do one specific thing - the library doesn't have any internal state. We'll call this a stack-based library as we can keep the call to the library on the stack and pop them off once we're done.

The second case we'll call a heap-based library where we're expecting the library to maintain a state through the lifetime of the trad4 application. This is the approach you'd take if you had an existing risk library with internal caches and states that were required for your library to operate.

The first case is pretty straightforward, the second case will almost certainly require some modification to your caching mechanism. I'll deal with these both in turn.

\section{Stack-based library integration}

Stack-based library integration is pretty straightforward as you just use the library as a service and you don't worry about any internal state it might have. To use a library in this way just do as follows (taken from vision_thing):

\begin{enumerate}

\item Set T4_3RD_PARTY_LIBS if you're using a shared library or T4_3RD_PARTY_AR if you're using static one:
\begin{verbatim}
export T4_3RD_PARTY_LIBS="$APP_ROOT/lib/3rd_party/libgd.so"
\end{verbatim}

\item Set T4_3RD_PARTY_HEADER_PATH to where the header includes are to be found:
\begin{verbatim}
export T4_3RD_PARTY_HEADER_PATH=$APP_ROOT/lib/3rd_party
\end{verbatim}

\item Include the header for the function you need in your object file:
\begin{verbatim}
#include "gd.h"
\end{verbatim}

\item Call the function as normal:
\begin{verbatim}
gdImagePtr master_img = gdImageCreate(master_img_width, master_img_height);
\end{verbatim}

\end{enumerate}

\section{Heap-based library integration}

Heap-based library integration is achieved with a similar procedure but one important difference: \emph{You are handing over the responsibility for object creation and deletion to the library itself.}

Up till now all the memory a trad4 app uses - described in the .t4 files - has been created by trad4 as described in the .t4 files. The static structures are created from the DB, the pub structures are populated from the calculate functions etc. 

By using heap-based libraries you're calling into the library through an api and the library handles the creation of it's internal data structures.

Now you're now calling this library from a multi-threaded client - you trad4 app. Is your library thread-safe? The answer is probably yes with some minor modifications.

Thread-safety isn't an objective thing. You don't write thread safe code, you write code that's tread safe in a particular threading context. Trad4 is a multi-threaded environment, but the calls into the library are single threaded. Just as multiple threads can rattle through a trad4 calculate function at the same time as they all have their own stack, so the single threaded calls can rattle round the library without any trouble, newing and deleting things as needed.

There are two potential problems though. The first is any internal caches used. The chances are they will have at their heart some kind of hash:

\begin{verbatim}
std::hash< key, object > objectCache;
\end{verbatim}

 This is all well and good in true single threaded mode but won't work in multi (specifically the periodic resizing of the hash by one of the threads will invalidate the handles the rest of the threads have to the hash. The solution is to remove the hash and replace it with a dumb array, using the trad4 id as the key:

\begin{verbatim}
object objectCache[MAX_OBJECTS]
\end{verbatim}

Where MAX_OBJECTS is defined in trad4.h.

As the trad4 approach is to load and keep all the objects we can be sure that a) we know how much memory will be used in advance and b) that MAX_OBJECTS will never be exceeded.

The second potential problem is you may have already made an attempt at making your library thread-safe though a liberal sprinkling of mutex locks. Wherever you see a mutex lock you should consider why it was introduced and if the problem it was introduced to solve is relevant in this context (e.g. writing to a log file) or not (protecting your now-replaced hash). If you have to keep them re-think if the functionality is required in the trad4 context. If you can remove them then do - they can severely degrade your system's performance and chances are they are not required in a trad4 context.

Of course, this is all hypothetical and I'm making some quite large assumption about your architecture and YMMV, but I'm available at very resonable rates to take a closer look...










\chapter{Living with trad4}

In this section we'll look at some of the issues that will arise in real-world deployments.

\section{Adding, removing and correcting objects at run-time}

Trad4 object should not change their identity during run-time. That means while it's fine to correct a bond's maturity date if it was first entered in error, but it would be inappropriate to change the identity of a bond from one to another. If a trade is attached to the wrong bond you don't update the bond, you update the trade to point to the correct bond.

\subsection{Corrections}

To correct an object update the object's data in the DB and set need_reload=1. Send the signal and the object's data is reloaded.

\subsection{Additions}

To add an object just add it's row in the relevant tables and once again send the reload signal. This object now starts. 

The thing you have to think about is what other connections this object has. It's trivial to add say an outright_trade at run-time as no objects subscribe to outright_trades in our model - they are at the top of the graph. If you were adding a bond, say, you'd have to give some thought to what trades connect to it.  In practise you'd probably be adding a bond because someone has just booked a trade against it. In this case you'd have to take care to start the bond before the trade, or start them both at the same time.

\subsection{Deletions}

The problem with additions becomes clearer when it comes to deletions. Were you to delete a bond that had attached trades, the behaviour of trad4 is currently undefined \footnote{But almost certainly bad.}.

\section{Adding and removing types at run-time}

As well as adding objects, you can also add new types while the system is running. Each type resides in it's own shared library which are loaded dynamically at run-time. To add a new type to a running trad4 application you:

\begin{enumerate}
\item Specify the object in the .t4 file. Run the precompiler and compile.
\item Add a row to the object_types table with need_reload=1
\item Trigger trad4 to reload the type.
\end{enumerate}

Trad4 will then load the new library and initialise the various structures. You can now add objects of this type as discussed above.

As always, care must be taken that you don't screw everything up. Changing a running type is inadvisable - you'd be better off creating a new type with the requisite changes and load that. Then migrate your object across from the old type to the new. During the weekly rebalancing (see below) you'd clean up the old type and tidy up the naming of the new.

\section{Working with multiple boxes}

In all the examples we've disused so far we've been working with a single box which is capable of running  all our objects. In large scale trad4 applications this will not be the case.

Say for example you have 100 books, each with hundred trades in each and assume a single box can't run this. We're sticking with bond_risk, so say 70% of the books are outright books and the rest are 
repo. Trades are divided into books roughly by the industry sector of the bonds. You have ten identical boxes all with plenty of cores and plenty of ram. How best to divide up the problem?

Your first instinct might to be to run ten books on each box, just ensuring that the number of trades on each box was roughly equal. The problem with this approach is that as the bonds in each book in the same sector, they are closely correlated. This close correlation means that were there a heavy day's trading in that sector you'd get one hot box and nine cool ones.

Far better to arrange your data so that objects of the same type share a box with those it's poorly correlated to. One way you'd do this is, as you're working through the trades in a particular book, assign them each to a different box in turn. As you reach the tenth box just start again from box one. In this way you ensure all your sectors are spread evenly across multiple boxes.

This approach does have one disadvantage in that you'll need to run all the ir_curves on every box, but as there are a small number of these (relative to the number of trades) this should not be a problem.

\section{Weekly rebalancing}

It is recommended that you shut your application down once a week for maintenance. The tasks you might want to perform are:

\subsection{Reassign any unused ids}

As objects are added and removed, the id's you use will become fragmented. While the system was down you would want to reassign these unused ids to known objects and free up space at the top of your id array for new objects the following week.

\subsection{Adding new and removing old types}

If you added new object types at runtime you might want to re-arrange them more comfortably in the configuration files. Likewise if you removed any object types when the system was up you would want to remove these from the system and reassigning the type ids.

\subsection{Check your headroom}

As trad4 relies wholly on fixed length arrays, running out of space mid-week should be avoided.  Meanwhile, while you need to keep a careful eye on your headroom and adjust your model parameters as necessary. If needs be, throw more hardware at the problem.

\section{Dynamic debug}

Dynamic debug is supported so you can set debug level at run-time on a per-object basis. 

There are four debug levels:

\begin{itemize}
\item log_level=0 will display no output
\item log_level=1 will display the published values
\item log_level=2 will show the above and the subscribed-to values
\item log_level=3 will show the above plus the workings of the need_refresh function
\end{itemize}

To set an object's log_level, run the sqlite3 client, aliased 't4db'

\begin{verbatim}
$ t4db
SQL> update object set log_level = <log level> where id = <id>
\end{verbatim}

Then run send_reload to pick up the changes:

\begin{verbatim}
$ need_refresh.sh
\end{verbatim}

Note: For this change to be picked up the object's need_reload flag on the object table will have to be set to 1. This is the default in most data sets in order to simplify the demonstration, but if your debug changes aren't being picked up you should check this flag.

\section{Input and Output}

\subsection{Input}

\subsubsection{Using the Database}

\subsubsection{Other Examples}

\subsection{Input}

\subsubsection{Using the Server}

\subsubsection{Other Examples}

\section{Run-time Validation and States}

Running objects can exist in one of three states.

\begin{itemize}
\item OK - Everything's fine and other objects can subscribe to these objects as normal.
\item STALE - The object's published data is sensible, but out of date. 
\item FAILED - Something's gone wrong with this object and it's published data is not to be touched.
\end{itemize}

These can get set when the object first starts and is validated, and also at run-time by flagging a failure in the object's calculate function.

\subsection{Validation}

When an object first starts or is reloaded, the sub object's are checked to see if they are up and running and of the correct type. If they are, the object is set to OK. If the sub objects are not running or of the correct type (due to a miss-configuration of the database), the object is set to FAILED, as there is no way the calculate function can be run, given that the sub objects are invalid. This object will stay in FAILED state until it is reloaded once the sub objects have started, or once it's sub data is corrected.

Any objects that subscribe to a FAILED object will set to FAILED during initial validation. 

\subsection{Run-time}

Once the system has successfully started, bad data can still be introduced to the system causing a failure in the calculate function. This is signalled by returning 0 from the function, which you the user are responsible for. For example:

\begin{verbatim}
    if ( denominator != 0.0 )
    {
        output = numerator / denominator;
        return 1
    }
    else
    {
        cerr << "Calculation failed: denominator = 0.0" << endl;
        return 0;   
    }
\end{verbatim}

Or if you're using exceptions:

\begin{verbatim}

    try {
        // calculate
    }
    catch(...) {
        cerr << "Calculation failed" << endl;
        return 0;
    }
    
    return 1;
\end{verbatim}

This will set this object's state to FAILED. In this case, as any objects that subscribe to that objects have already run and have good pub data, these objects don't fire when they are run and the state is set to STALE. This means the pub data is still good, just out of date.

Next, any objects that subscribe to STALE objects can continue to use their data, plus the data from any other OK objects it also subscribes to. In this way these objects can continue to update with a mixture of OK and STALE data. These objects will themselves be set to STALE.

In this way, a trad4 application is very robust - a FAILED object can't bring down the system - it will just cause a ripple of STALE objects up the hierarchy.

\appendix

\chapter{How trad4 works}

In this appendix we discuss how trad4 does what it does on a technical level. This is solely a discussion on the internals of trad4 - you may organise your calculate functions as you see fit.  First a brief introduction to the kinds of data structures you will see. 

Trad4 only uses fixed length arrays. This is because these will be optimised away by the compiler to some integer arithmetic and a jump or two, and hence are very efficient. I realise you have to ensure these are sufficiently big to hold all the data you might need, and therefore waste RAM, but as you should be running on a chunky 64-bit host this shouldn't be a problem. As an example bond_risk_440k - a data set with 440k bond_risk objects takes up around 120 MB of RAM. 

Internally, trad4 uses these fixed length arrays in two different ways.  Firstly, there is the 1-based model used by the objloc - each object uses it's unique id to index into the objloc, and as there are no objects with id=0, the array is 1-based.

Secondly there is the 0-based model as used by the tier_manager but this time treating them as stacks - using the value at 0 to track the number of elements in the array, adding to and removing from the end.

\section{The trad4 structures}

\subsection{The objloc}

\begin{verbatim}
void* obj_loc[NUM_OBJECTS+1]
\end{verbatim}

The objloc is an array of void*. It is used by the threads to locate the objects and the objects to locate each other. When the system is starting, each object is loaded which involves newing off a struct of it's type and placing a pointer to this struct into the objloc using it's id as the offset.  In this way, if bond US1 has an id of 6,

\begin{verbatim}
bond* myBondUS1 = (bond*)obj_loc[6];
\end{verbatim}

We can then read or write to US1's struct using just it's id and a pointer to the objloc.

Likewise, when a thread is assigned an object, it is assigned by passing in the object id it's supposed to run. It first locates the object's struct using the method above, then it locates the pointer to that object's 
calculate function by looking it up on the object's struct. This is discussed further below.

The way the master thread handles these heterogeneous objects is by using the header. The structs of all object types start with the same size and shaped header. This means the master thread can examine the timestamps on the objects by casting the void* it gets back to the objloc into a struct of type object_header, like so:

\begin{verbatim}
((object_header*)obj_loc[id])->last_published
\end{verbatim}

\subsection{The thread_controller}

\begin{verbatim}
int thread_controller[NUM_THREADS+1]
\end{verbatim}

The thread_controller is used by the master and worker threads to communicate. Each thread has it's own id which is used to index into this array. The contents of the thread_controller for a particular thread is the id of the object that the thread is currently associated with. 

When the master thread finds an object that need to fire if finds a free thread by traversing the thread_controller and finding one where

\begin{verbatim}
thread_controller[i] == 0
\end{verbatim}

This means that thread i is idle. The master thread then writes the id of the object it wants thread i to work on to thread_controller[i]. The master is now done and can continue traversing the tier it's working on looking for more objects to run. 

\subsection{The object_type_struct}

\begin{verbatim}
object_type_struct_t* object_type_struct[MAX_TYPES+1];
\end{verbatim}

Where

\begin{verbatim}
typedef struct {
    void* lib_handle;
    calculate_fpointer calculate;
    need_refresh_fpointer need_refresh;
    load_objects_fpointer load_objects;
    validate_fpointer validate;
    print_concrete_graph_fpointer print_concrete_graph;
    get_object_size_fpointer get_object_size;
} object_type_struct_t;
\end{verbatim}

The object_type_struct is where the type-specific information is stored. Every type (e.g. bond, outright_trade) is dynamically loaded from it's own library. Pointers to the functions every trad4 object must have are stored on the object_type_struct, as well as a pointer to the library itself.  

\begin{enumerate}
\item lib_handle is a pointer to the object's dynamically loaded .so.
\item The calculate_fpointer is a function pointer to the object's calculate function. Run by the worker 
threads.
\item The need_refresh_fpointer is a function pointer to the object's need_refresh function. Run by the master thread.
\item The load_objects_fpointer is a function pointer to the object's load_objects function. This will (re)load all objects of this type that need it. Run by the master thread.
\item The validate_fpointer is a function pointer to the object's validate function. This checks if the subscribed-to objects are of the correct type and in the correct state.
\item The print_concrete_graph_fpointer is a function pointer to the print_concrete_graph function, used to generate the concrete graph of a particular application.
\item the get_object_size_fpointer is a function pointer to the get_object_size function, used as part of the TCP/IP server to retrieve objects from a running application.
\end{enumerate}

\subsection{The object header}

\begin{verbatim}
typedef struct {
    // Header
    long long last_published;
    long id;
    e_status status;
    int type;
    int tier;
    char name[OBJECT_NAME_LEN];
    int log_level;
    int implements;
    int init;
} object_header;
\end{verbatim}

The object header forms the first part of every object's struct. Because it is common to all objects, heterogeneous objects can be handled generically through this header.


\begin{enumerate}
\item The last_published member gives when the object was last published, and is used to decide weather objects that subscribe to this objects need to be re-run.
\item The id is the object's unique id.
\item The status gives the object status - OK, STALE or FAILED.
\item The type is the object's type id.
\item The name is the object's name.
\item The log_level is the object's log level.
\item The implements member is used for inheritance of interface, and gives the type id of the type it's inheriting from. This is used for validation.
\item The init flag gives weather the object has just started or reloaded. Useful if your types need any special initialisation handling.
\end{enumerate}

\subsection{The object struct}

For this example we'll look at a bond from bond_risk. This struct is generated from the.t4 file, and all an object's data is stored here. You'll see the common header takes up the first part of the struct, and the rest comes from the .t4 file.

\begin{verbatim}
typedef struct {
    // header
    long_long last_published;
    long id;
    e_status status;
    int type;
    int tier;
    char name[OBJECT_NAME_LEN];
    int log_level;
    int implements;
    int init;

    // sub
    int calendar;
    int ir_curve;

    // static
    date start_date;
    date maturity_date;
    int coupons_per_year;
    double coupon;

    // pub
    double price;
    double pv01;
} bond;
\end{verbatim}

The sub section gives the id's of the objects o which it subscribes. The static section is where the data from the DB is loaded and stored. The pub section is where the result of the calculate function is published.

\section{The threads}

Trad4 uses the master-worker thread model.

TODO: XP with DB reloads (no need for trigger objects?) (test)

From a steady-state, the master thread loops through the T1 objects. If a send_reload signal has been sent, some of one or more object's data been reloaded from the DB . If the master thread finds a T1 object that's updated it will pick a thread out of the thread pool and associate it with that object that needs to fire. The thread then runs the object. 

The master thread then continues through the rest of the T1 objects and in the event of any more of them having been updated it will fire these as well.

Trad4 now knows there's change afoot. It waits for all the threads running T1 objects to complete and moves onto the T2 objects. It runs through all the T2 objects, checking the T2 objects timestamp against the T1 object to which they subscribe. If any are found that need to fire, the master thread again associates that object with a thread and continues through all the T2 objects. Again it waits for the threads working on the T2 objects to complete before moving on to the T3 objects.  This process continues until all the tiers are run. When that's done, the master thread goes back to looping through the T1 objects looking for change.  

If, during the master thread's traversal it finds an object that needs to fire but there are no spare threads, is simply sleeps for a short, adjustable time until one becomes available.

\subsection{The worker threads}

The worker threads all sit in a loop, sleeping and checking to see if their thread_controller[i] has been set to an object id by the master thread. if it has been set, the thread can then call that object's calculate 
function by, for thread N:

a) Locating the object's struct:
\begin{verbatim}
void* my_object = obj_loc[thread_controller[N]];
\end{verbatim}

b) Finding this object's type by casting it's void* into an object_header* and dereferencing:
\begin{verbatim}
int my_type_id = ((object_header*)my_object)->type  
\end{verbatim}

c) Using that type_id to index into the object_type_struct and finding that type's calculate_fpointer:
\begin{verbatim}
void* my_calculate_fpointer = (*object_type_struct[my_type_id])->calculate
\end{verbatim}

d) Call that function, which takes the objloc and the object id (which is still given by thread_controller[N]) as the arguments:
\begin{verbatim}
(my_calculate_fpointer)(obj_loc, thread_controller[N]);
\end{verbatim}

Again this is done more concisely in the code.

\section{The generated functions}

These are the more interesting functions generated for you by trad4. They are all found in bond_risk/gen/objects/*_wrapper.c.

\subsection{The need_refresh function}

\begin{verbatim}
int bond_need_refresh( obj_loc_t obj_loc, long id )
\end{verbatim}

To illustrate how it works we'll again look at a bond with id 'id'.  First the thread locates the struct of the object it's working on as discussed above:

\begin{verbatim}
bond* my_bond = (bond*)my_object;
\end{verbatim}

The thread can then find the timestamp of this object:
\begin{verbatim}
int my_timestamp =  my_bond->last_published;
\end{verbatim}

Next the bond needs to locate the timestamp of the object to which it subscribes - in this case, the 
currency curve. It does this by:

a) First looking up the id of the currency_curve it subscribed to by:
\begin{verbatim}
int cc_id = my_bond->currency_curves;
\end{verbatim}

b) Using the currency curve id to index into the objloc to find the void* to it's struct:
\begin{verbatim}
void* sub_object = obj_loc[cc_id];
\end{verbatim}

c) Casting that to a pointer of the right type:
\begin{verbatim}
currency_curves* sub_currency_curves = (currency_curves*)sub_object;
\end{verbatim}

d) Find the currency curves' last_published timestamp:
    
\begin{verbatim}
int sub_currency_curves_timestamp = sub_currency_curves->last_published;
\end{verbatim}

e) Compare the two and return the result:
\begin{verbatim}
return ( my_timestamp < sub_currency_curves_timestamp );
\end{verbatim}

This is complicated when an object subscribes to more than one object, but in practise the various results are just ORed together. 

\subsection{The calculate function wrapper}

\begin{verbatim}
void calculate( obj_loc_t obj_loc, long id )
\end{verbatim}

The calculate wrapper calls the various debug macros (if enabled) before and after calling the user-
supplied calculate function:

\begin{verbatim}
DEBUG_FINE( "\tbond_coupon: " << bond_coupon );
...
calculate_bond( obj_loc, id );
...
DEBUG( "\tbond_dv01: " << bond_dv01 );
\end{verbatim}

Some of the state management is also handled in the calculate function wrapper.

\subsection{The calculate function}

\begin{verbatim}
int calculate_bond( obj_loc_t obj_loc, long id )
\end{verbatim}

This is the function that the user supplies that transforms the object's inputs and static into the outputs.  The calculate function is supplied with macros that abstract away the complex lookups and casts from the user. In this way the calculate function of the outright trade looks like:

\begin{verbatim}
outright_trade_pv = ( outright_trade_quantity * bond_price );
\end{verbatim}


\section{The macros}

These work as follows: outright_trade_pv actually looks like:

\begin{verbatim}
#define outright_trade_pv ((outright_trade*)obj_loc[id])->pv
\end{verbatim}

And within the outright_trade's calculate function, bond_price looks like:

\begin{verbatim}
#define bond_price ((bond*)obj_loc[((outright_trade*)obj_loc[id])->bond])->price
\end{verbatim}


\end{document}

