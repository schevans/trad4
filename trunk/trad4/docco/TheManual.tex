% Copyright (c) Steve Evans 2010
% steve@topaz.myzen.co.uk

\documentclass{report}

\usepackage{underscore}
\usepackage{times}

\begin{document}

\title{The Manual}
\author{Steve Evans}
\maketitle

\chapter{Introduction}

\chapter{Example: Hello world!}

\chapter{New Application Walkthrough}

\section{Run create_new_app.sh}

Change directory into trad4's bin directory and run the script, giving your new app name as the argument.

\begin{verbatim}
    trad4/bin$ ./create_new_app.sh <app_name>
\end{verbatim}

This will create the directory structure for your new application, plus a couple of files you'll be needing.

For the rest of this chapter substitute simple_maths for your application, or follow along with a downloaded  distribution of simple_maths.

\section{Source your .conf file}

You should always source the relevant .conf file at the beginning of each session to set the environment  up:

\begin{verbatim}
simple_maths$ . ./simple_maths.conf
\end{verbatim}

\section{Write your .t4 files}

Set out the sub, static and pub sections. For example, the .t4 file for the type 'a' from simple_maths is:

\begin{verbatim}
static
    int out
\end{verbatim}

As you can see, this type just has a single static variable of type int. This is loaded when the object is started and doesn't change unless it reloads a new value from the database.

The .t4 file for the type 'x' from simple_maths is:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Type x has a sub section, describing the type and name of the objects to which it subscribes. In this case it's a type a as described above and a type b (not shown, but identical to a.t4). There is one variable in the pub section this is where x publishes it's output value, called 'out' of type int.

The sub types in the .t4 files must always be of another trad4 type. The static and pub types can be of the following built-in C++ types:

\begin{itemize}
\item int
\item char
\item float
\item double
\item long
\end{itemize}

Arrays are supported in the sub, static and pub sections. Also, constants, enums, aliases and structures can be defined and also used in the static and pub sections. More on this later.

\section{Edit your object_types.t4s file}

This file contains an entry for each type:
\begin{verbatim}
#type_id, tier, name
1,1,a
2,1,b
3,1,c
4,1,b
5,2,x
6,2,y
7,3,z
\end{verbatim}

Each type must have it's own unique type_id, it's tier must be specified and it's name must be unique. 
Anything to the right of a hash will be considered a comment and ignored.

In this case there are seven types. The T1 types are a,b,c and d. There are two T2 types x and y, and one T3 type z.

\section{Run the trad4 precompiler}

The precompiler ­ precomp.pl ­ is aliased to 't4p':

\begin{verbatim}
    $ t4p
\end{verbatim}

This will create several files under your root directory, the most important of which to you are the files under simple_maths/objects. These files ­ one per object ­ contain the stub calculate functions that you must provide the logic for.  You could supply this functionality now, or if you're impatient you can skip to the next step and supply the functionality later.

A generated file you will be needing are the macros under simple_maths/gen/objects and have the file name $<$type$>$_macro.h. There's a comment at the top of this file that shows you what's in scope for the calculate function.

Also generated by the precompiler are the .table files that specify the default database structure. These are found under simple_maths/gen/sql. There is even some dummy data created under simple_maths/data/dummy_data.

The rest of the files produced by the precompiler provide the guts of the trad4 application and you will probably not be interested in. They reside with the macros under simple_maths/gen/objects.

The precompiler supports various command­line options, e.g.:

\begin{verbatim}
simple_maths]$ t4p -h
Usage: precomp.pl [OPTION]
The trad4 precompiler.

  -o <object>    precompile <object> only
  -k             continue on error
  -c             remove all generated files
  -a             remove all generated files and regenerate
  -v             verbose - dumps internal structures
  -d             generate documentation
  -h             display this help and exit
\end{verbatim}

\section{Choose how many threads you need}

To set the number of threads used you set the NUM_THREADS environment variable.

\begin{verbatim}
    $ export NUM_THREADS=16
\end{verbatim}

The default for a new application is 0, which means the master thread does all the work. Setting NUM_THREADS=1 means there is one master thread and one worker thread. The maximum is 4096.

As with all the environment variables, they can be set in app.conf file.


\section{Create the database}

Trad4 uses sqlite, a serverless flat file database. The structure is generated for you by the precompiler, as is some dummy data to get you started.

\begin{verbatim}
    $ recreate_db.sh
\end{verbatim}

This will load the table definitions generated under simple_maths/gen/sql into the DB, and (re)create the 
system tables.

Next, load the default data set:

\begin{verbatim}
    simple_maths/data$ reload_db.sh default_set/
\end{verbatim}

\section{Compile the application}

To compile the application, just type make:

\begin{verbatim}
    simple_maths$ make
\end{verbatim}

This will compile and link your application and produce an executable binary of the same name as your 
application. You can run it now if you like. 

\begin{verbatim}
    simple_maths$ bin/simple_maths
\end{verbatim}

You should see the types being created, then the load functions being called and the objects being created (there's a one-to-one correspondence between the types and objects in this simple model). The objects are then validated and a short report is produced. The tiers are then run in turn and all the calculate functions being called, but they won't do anything yet as the logic hasn't yet been provided.

The application should then exit as BATCH_MODE is set as default, which caused the application to exit after the first run.

\section{The Calculate Function}

\section{The Object Data}

\section{Triggering an update}

To trigger an update you first need to set the need_reload flag on the object table to 1 for those objects you want to reload:

\begin{verbatim}
    SQL> update object set need_reload = 1 where id in (...);
\end{verbatim}

You'll then need to unset BATCH_MODE so that the application continues running. Then you send a signal to your application that there's one or more objects that need to be reloaded:

\begin{verbatim}
    $ send_reload.sh 
\end{verbatim}

You will then see all the objects triggering in the order you expect. All the calculate functions will be called, and you should see the affect of your update on the output.

Note that the dummy_data set created for you has need_reload=1 for all objects.

\section{Tips and Tricks}

Keep it simple for now and restrict yourself to two or three types when you're starting a new application.

\chapter{Further Language features}

\chapter{Tips and tricks}

\chapter{Living with trad4}

\chapter{Hardware considerations}

\appendix

\chapter{How trad4 works}

\end{document}

