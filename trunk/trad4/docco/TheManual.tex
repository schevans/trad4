% Copyright (c) Steve Evans 2010
% steve@topaz.myzen.co.uk


\documentclass{report}

\usepackage{underscore}
\usepackage{times}
\usepackage{graphicx}

\begin{document}

\title{The Manual}
\author{Steve Evans}
\maketitle

\setcounter{tocdepth}{1}
\tableofcontents

\chapter{Introduction}

Trad4 is a programming language with which you describe the relationship and behaviour of a set of object of different types. 

Features:

\begin{itemize}
\item add and remove objects at run time
\item add and remove types at run time
\item full lock-free concurrency
\item run-time fault-tolerance
\item 3rd-party library integration (restrictions apply: you have to keep them on the stack)
\end{itemize}

There are three applications discussed in this document: hello_world, simple_maths and bond_risk. There are other applications available and written up incline.

Time for an example.

\chapter{Example: Hello world!}

\section{Introduction}

The first trad4 application we'll examine is the venerable "Hello world!".

\includegraphics[scale=0.5]{helloworldabstract.png}

The above application is a directed acyclic graph, and it shows three types. Two on tier1 (T1) - hello and world, and one on T2 - hello_world. The T2 hello_world object subscribes to the two T1 objects. The hello_world object simply concatenates the names of the two objects and prints them out.

What will happen when the application starts is that the T1 objects will run concurrently (they do nothing in this simple example), then the T2 object will run. This will read the names of the T1 objects and concatenate them and print the result. The output is below.


\begin{verbatim}
~/src/hello_world$ hello_world
Creating new type hello, type_id: 1
Creating new type world, type_id: 2
Creating new type hello_world, type_id: 3
Loading objects...
Loading hello..
Loading world..
Loading hello_world..
Validating objects...

Num objects on T1: 2
Num objects on T2: 1

Running in single-threaded mode.

Tier 1 running.
Tier 1 ran 2 objects in 6.60419e-05 seconds.

Tier 2 running.
Hello world!
Tier 2 ran 1 objects in 2.88486e-05 seconds.

All tiers ran 3 objects in 0.000231981 seconds.

Exiting after first run as BATCH_MODE is set.
\end{verbatim}

When the application hello_world starts, it first creates the three types we discussed above. Next the objects themselves are loaded. Next the objects are validated and the number of objects on each tier reported. This application is set to use single-threaded mode to keep the output orderly. 

Next we'll see how these types are defined.

\section{The .t4 files}

The way types are defined is in their *.t4 file in the src directory. The types hello and world are the simplest possible as they do absolutely nothing and thus .t4 files are empty, but hello_world.t4 is shown below:

\begin{verbatim}
sub
    hello hello
    world world
\end{verbatim}

The .t4 files are split into three sections. The sub section as shown above describes the type and name of the other trad4 types to which this this type subscribes. In this case hello_world subscribes to two types, the first being a hello object called hello, and the second a world object called world.

The other two sections are static - where the object keeps it's static data which is loaded from the database, and the pub section - where the intermediate and final values of the object's calculate function are stores and published to the world. Neither of these two sections are used in this simple model.

Each type must also have an entry in the object_types.t4s file (the 's' stands for system). This is shown below:

\begin{verbatim}
#type_id, tier, name
1,1,hello
2,1,world
3,2,hello_world
\end{verbatim}


The type_id must be unique. From this we can see type hello has an type_id of 1 and exists on tier 1 and world has an type_id of 2 and also exists on tier 1. The hello_world type has an type_id of 3 and exists on tier 2.

\section{The Calculate Function}

Now we have described the type, we must specify what is does, in this case concatenating the names of the two objects and printing it out.

A stub calculate function is generated for you by trad4, and is found in the objects directory. Again, hello and world do nothing but hello_world's calculate function is shown below:

\begin{verbatim}
int calculate_hello_world( obj_loc_t obj_loc, int id )
{
    cout << object_name(hello_world_hello) << " " << object_name(hello_world_world) << "!" << endl;

    return 1;
}
\end{verbatim}

Trad4 pulls all the information from the sub objects into the scope of this function using macros. You need not concern yourself how these macros work, just think of then as variables which will do what you expect. The functions signature is boilerplate to allow the macros to work and can be ignored. Also ignore the return value for now.

In this case there's very little information in the sub objects, just their id. The macros used above are shown below (from gen/objects/hello_world_macros.h):

\begin{verbatim}
sub:
    id hello_world_hello
    id hello_world_world
\end{verbatim}

So this shows that within calculate_hello_world there's a variable hello_world_hello in scope that will return the id of the hello object. Likewise there's a variable hello_world_world that will return the id of the world object. These id's we can use in the trad4 object_name function to return the name of the object, which is exactly what calculate_hello_world does above.

\chapter{Example: Simple Maths}

\section{Introduction}

We're going to move on to a more complex example in order to demonstrate the concurrency. We want to model the following simple problem:

\begin{math}
  \begin{array}{ l c }
        & z = x + y   \\
        where         \\
        & x = a + b   \\
        & y = c + d   \\
        and           \\
        & a = 7       \\
        & b = 14      \\
        & c = 6       \\
        & b = 27      \\
  \end{array} 
\end{math}

The abstract graph for simple_maths is as follows:

\includegraphics[scale=0.5]{simplemathsabstract.png}

From this we can see that should a, b, c, and d all change we can run x and y at the same time, followed by z. Likewise, if only a changes we only need to recalculate x. Another point to note it that there is just one instance of \begin{math} a + b\end{math} in the whole system - any other object that requires that result subscribe to the x object and read it from there. We will see later how it's possible to decompose quite complex problems into trad4 applications and have fragments of them run concurrently.

\section{The .t4 Files}

In this example the .t4 files are a little more interesting. Below, a.t4:

\begin{verbatim}
static
    int out
\end{verbatim}

Here type a has only one member, it's in the static section and it's an int called out. It's in the static section as the data is stored in the database. More on this below.

The .t4 file for b, c and d are identical to a's and not shown. The .t4 file for x is shown below:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Here type x has three members. The first two are in the sub section and shows x subscribes to a type a called a, and a type b of name b. It also has an int called out in the pub section, where the result of \(a + b\) will be stored to be consumed by z.

The .t4 files for y and z are similar to x's and not shown. In fact there's a more concise way to arrange similar t4 types using inheritance of interface (IoI), as discussed in general_computer below.

\section{The Calculate Function}

The calculate functions for a, b, c and d do nothing, as the types consist entirely of a single static member which is just published to to the world at large without any processing. The calculate_x function is shown below:

\begin{verbatim}
int calculate_x( obj_loc_t obj_loc, int id )
{
    x_out = a_out + b_out;

    return 1;
}
\end{verbatim}

Again these variables are provided by macros (from gen/objects/x_macros.h):


\begin{verbatim}
sub:
    id x_a
    int a_out

    id x_b
    int b_out

static:

pub:
    int x_out
\end{verbatim}

Here you can see for each sub member two variables are provided, in a's case these are x_a which provides it's id, and a_out where a will publish it's static data. Also in the pub section is the int x_out, where the result of  \(a + b\) is published. So calculate_x takes the published a_out and b_out variables, adds them and publishes the result in x_out.

The calculate functions for y is very similar to that of x, but z's includes some output:

\begin{verbatim}
int calculate_z( obj_loc_t obj_loc, int id )
{
    z_out = x_out + y_out;

    cout << "z_out: " << z_out << endl;

    return 1;
}
\end{verbatim}

\section{The Data}
\label{sec:The Data}

In the first example hello_world we ignored the database to keep things simple, but we need to introduce it now. Trad4 uses sqlite - a serverless database written in C. All the tables you need (and some of the data) are generated for you by the precompiler, but you need to provide the data for. 

At this stage we also need to distinguish between objects and types. Types are the trad4 types as described in their .t4 files and calculate function. Objects are the running, instantiated types, described in the database. This discussion is confused by the fact that in this application and in hello_world, each type has a single instantiated object with type_id=id. This will become clearer later as we have multiple objects of particular types as in bond_risk below.

The main table in the database is the object table, in which every object has an entry. This table is shown below:
 
\begin{verbatim}
create table object (
    id int, 
    type_id int,
    tier int,
    name char(32),
    log_level int,
    need_reload int
);
\end{verbatim}

The id is the unique id of this object. The type_id gives the type of the object, as described in the object_types.t4s file described above. The tier gives the tier this object exists on, as objects of the same type can exist on different tiers in certain circumstances. The name field holds the name of the object which we pressed into service in hello_world. The log_level controls the level of logging the object does, and need_reload controls whether of not the object needs to be reloaded when the application receives a reload signal (more on this later).

As well as the object table, each type has one or more type-specific tables. In simple_maths this is just one table per type. Below is the table for a (from gen/object/sql):


\begin{verbatim}
create table a (
    id int,
    out int
);
\end{verbatim}

There is the primary key id, plus the static value of the out variable. So the data for object a of type a is given by (from data/worked_example/a.sql):

\begin{verbatim}
insert into object values ( 1, 1, 1, "a", 1, 0 );
insert into a values ( 1, 7 );
\end{verbatim}

So we can see an object with id of 1, type 1 running on tier 1 called "a" with log_level 1 and need_reload set to 0. In type-specific table a there's the primary key id and the value of out, given by 7. The data for objects b, c and d are similar to this, except they have different ids, type_ids, names and static out values as described above. The data for object x is given by:


\begin{verbatim}
insert into object values ( 5, 5, 2, "x", 1, 0 );
insert into x values ( 5, 1, 2 );
\end{verbatim}

This shows an object with id 5, type 5, tier 2 etc. In type-specific table x there's the primary key id and the ids of the two objects to which x subscribes, namely a with id 1 and b with id 2. 

Now we have the full description of this application we can run it:

\begin{verbatim}

~/src/simple_maths$ simple_maths
Creating new type y, type_id: 6
Creating new type c, type_id: 3
Creating new type a, type_id: 1
Creating new type b, type_id: 2
Creating new type x, type_id: 5
Creating new type d, type_id: 4
Creating new type z, type_id: 7
Loading objects...
Loading y..
Loading c..
Loading a..
Loading b..
Loading x..
Loading d..
Loading z..
Validating objects...

Num objects on T1: 4
Num objects on T2: 2
Num objects on T3: 1

Running in single-threaded mode.

Tier 1 running.
calculate_a( a )
calculate_b( b )
calculate_c( c )
calculate_d( d )
Tier 1 ran 4 objects in 8.89301e-05 seconds.

Tier 2 running.
calculate_x( x )
calculate_y( y )
Tier 2 ran 2 objects in 4.60148e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 54
Tier 3 ran 1 objects in 3.60012e-05 seconds.

All tiers ran 7 objects in 0.000287056 seconds.

\end{verbatim}

As in the previous example you can see the types being created and the objects being loaded and validated. Then from the report you can see we have 4 objects in T1, 2 on T2 and 1 on T3, as expected. Then the tiers are run as before, with z producing the output 54.

\section{Feeding in change}

In this case the applications doesn't terminate after the first time all the tiers are run, but loops over the objects on T1 looking for change. We introduce change as follows:

\begin{enumerate}

\item Change the required values in the database and set the need_reload flag.
\item Send the application a signal to indicate something has changed.

\end{enumerate}

So we'll update a's static data and trigger a reload. First we log into the database and make the changes:

\begin{verbatim}

~/src/simple_maths$ t4db
sqlite> update a set out=19 where id=1;
sqlite> update object set need_reload=1 where id=1;

\end{verbatim}

And send the reload signal:

\begin{verbatim}

~/src/simple_maths$ send_reload.sh

\end{verbatim}

This produces the following output:

\begin{verbatim}

Tier 1 running.
calculate_a( a )
Tier 1 ran 1 objects in 5.00679e-05 seconds.

Tier 2 running.
calculate_x( x )
Tier 2 ran 1 objects in 3.91006e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 66
Tier 3 ran 1 objects in 4.19617e-05 seconds.

\end{verbatim}

Notice only a, x and z fired, the minimum needed to recalculate z given that only a had changed. Next we'll update b and c (ids 2 and 3):

\begin{verbatim}

~/src/simple_maths$ t4db
sqlite> update b set out=23 where id=2;
sqlite> update c set out=46 where id=3;
sqlite> update object set need_reload=1 where id in ( 2, 3 );

\end{verbatim}

This produces the following output:

\begin{verbatim}
Tier 1 running.
calculate_b( b )
calculate_c( c )
Tier 1 ran 2 objects in 7.29561e-05 seconds.

Tier 2 running.
calculate_x( x )
calculate_y( y )
Tier 2 ran 2 objects in 3.60012e-05 seconds.

Tier 3 running.
calculate_z( z )
z_out: 115
Tier 3 ran 1 objects in 2.69413e-05 seconds.
\end{verbatim}

From this you can see both b and c on T1 and x and y on T2 both run concurrently. 

If fact in this example they don't as we're running is single threaded mode to keep the output orderly, but this is easily set with the environment variable NUM_THREADS, e.g.:

\begin{verbatim}
~/src/simple_maths$ export NUM_THREADS=64
~/src/simple_maths$ simple_maths
\end{verbatim}

\chapter{Example: Bond Risk}

\section{Introduction}

Now we're going to examine a real world example of the trad4 architecture from the world of finance - bond_risk. This is a model that calculates the risk on two financial instruments - bonds and outright trades - that depend on the expected future values of interest rates. In this first chapter we'll be examining a cut-down version of the final app. In the next chapter we'll extend the model and examine how it handles under load.

First, the abstract graph:

\includegraphics[scale=0.5]{bondrisksimpleabstract.png}

Note that in this chapter we're looking at a simplified version of bond_risk, where we're ignoring the types repo_trade and book for now. TODO - bond_risk_simple

\subsection{T1: ir_curve}

The first type on T1 is ir_curve. This contains information about the expected future value of interest rates. We observe information from the markets to obtain a set of input_rates, and construct a curve starting today and going forward to a set endpoint (say 20 years). This constructed curve has an entry for each day from today to 20 years containing information derived from our input rates, which will be consumed by the T2 bond objects. The key point to note about ir_curves is that they are expensive to construct - the various algorithms used to bootstrap and interpolate the various curves are computationally expensive.

\subsection{T2: bond}

The second type on T2 is bond. A bond is a financial instrument that you buy for a certain price, and pays you fixed payments or coupons at a certain rate until it matures (say 20 years). Because it pays you money at a fixed rate (say 3\% per year), it will become more or less valuable depending on the current and expected future value of interest rates. A bond that pays 3\% when interest rates are 3% will be worth 100 (they are bought and sold in lots of 100), but it will have a higher price when interest rates are at 1\% (say 102.8) then when they are at 5\% (say 97.8) because they pay out more than that same £100 would in the bank (at 3%).

TODO: Real data from worked_example.

\subsection{T3: outright_trade}

The last type on T3 is outright_trade. This trade captures value of the purchase of a bond at a particular time. If you buy a bond with a price of £100 today, and the bond price rises in the future because interest rates fall, the present value (pv) of that trade increases. If you sell the bond at that future time you stand to make a profit. This profit or loss (pnl) is calculated by the original price of the bond and the bond's current published price.

\subsection{Risk: pv01}

In addition to bond's price and outright_trade's pv and pnl, there are other risk measures we can produce for these types, and in this example we're going to focus on is pv01. The pv01 of a bond is the amount the price or present value (pv) will change given a small shift - 1 basis point (bp - 100th of a percent) - in interest rates. If a bond has a high pv01 it's price is likely to be very sensitive to interest rate movements and be inherently more risky. A bond with a low pv01 will be less sensitive to interest rates. 

Likewise an outright_trade on a bond with a high pv01 will itself be sensitive to the volatility of the bond, so it will have an indirect sensitivity to interest rates.

The way pv01 is calculated is that the ir_curve is bumped or perturbed up by 1bp and the bond is priced against that perturbed curve. Then then original ir_curve is bumped down by 1bp and again the bond is priced. The difference between these two prices is the pv01.

From the perspective of the trad4 architecture this is quite easy to achieve: We just have the ir_curve type also produce bootstrapped curves perturbed up and down by 1bp. Then bond can read the bumped and un-bumped forward rates directly from the ir_curve objects. 

\section{The Concrete Graph}

In Section ~\ref{sec:The Data} the distinction between types and objects was made. This becomes clearer now as in this data set we will have two ir_curves, five bonds and nine outright_trades. These objects - instantiated types - are shown on the concrete graph represented by ovals containing the object name. This is shown below:

\includegraphics[scale=0.3]{bondrisksimpleconcrete.png}

From this we can see the two ir_curves in two different currencies LIBOR.USD and LIBOR.GBP on T1. Then we can see the five bonds on T2, two of which were issued in USD (US01 and US02) which subscribe to LIBOR.USD, and three of which were issued in GBP which subscribe to LIBOR.GBP. Lastly we have the nine outright_trades (OT01 etc.) which subscribe to various bonds.


\section{The t4s files}

The bond_risk application uses some more advanced features of trad4, specifically constants, enums, aliases and structures. These will be introduced in the next section and expanded on in section ~\ref{sec:Language Features}. Additionally ir_curve uses array members, which will be discussed in that section.

The t4s files are the trad4 system files that you supply as you need the relevant features. They described below.

\subsection{constants.t4s}

The constants.t4s file allows you to define your own constants that will be in scope in all calculate functions. Below, bond_risk's constants.t4s file:


\begin{verbatim}
TODAY = 40403            # 13/08/2010
END_DATE = 47708         # 13/08/2030

NUM_FORWARD_DAYS = END_DATE - TODAY

NUM_INPUT_RATES = 10

YEAR_BASIS = 365.25
\end{verbatim}

This describes the start and end dates covered by this model, and the number of forward dates are calculated from that data. Also the number of input_rates is set here, as is the year basis which describes how years are calculated.

\subsection{enums.t4s}

You can define your own enums to use in the t4 files in src/enums.t4s. There's only one enum used in bond_risk, used to indicate the direction of a trade:

\begin{verbatim}
buy_sell_enum
    BUY
    SELL
\end{verbatim}


\subsection{aliases.t4s}

Aliases are simply typedefs, used to clarify your t4 files and structures:

\begin{verbatim}
date = long int
\end{verbatim}

\subsection{structures.t4s}

Any structures you require in your t4 files can be described in structures.t4s. Again there's only one structure used in bond_risk, and that's a rate, described by a value on a particular date (the date given in aliases.t4s):

\begin{verbatim}
rate
    double value
    date asof
\end{verbatim}

Given the above definitions, we can now tackle bond_risk's t4 files. We will look at each type in turn.

\section{ir_curve}

\subsection{The t4 files}

The t4 files are divided into three different sections (all of them optional) - there's the sub section, which lists the other types to which this type subscribes, the static section which is driven by the object's database tables, and the pub section where the results of the calculations using it's static and the pub and static sections of the objects to which it subscribes. These will be discussed in more detail below.

\begin{verbatim}
static
    rate input_rates[NUM_INPUT_RATES]

pub
    double interest_rate_interpol[NUM_FORWARD_DAYS]
    double discount_rate[NUM_FORWARD_DAYS]
    double discount_rate_p01[NUM_FORWARD_DAYS]
    double discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

\subsubsection{The static section}

The static section is populated from the object's database tables. This data is loaded when the object starts, and may be reloaded at run-time. The static section is published to the rest of the world, but it's not touched by the calculate function.

In this section above we can just see the input_rates, which are an array of rates - the structure defined above - of length NUM_INPUT_RATES as defined in constants.. This is an input to our model, as we're going to move interest rates up and down to see how our bond's and trade's price and risk respond. 

\subsubsection{The pub section}

The pub section is where the results of the object's calculate function are published to the rest of the world. The variables in this section are zeroed when the object starts, and are used as intermediate and final results in the calculate function. If you add a variable to the pub section you will not need to modify the database.

In this section we have four arrays of doubles of length NUM_FORWARD_DAYS. The interest_rate_interpol array is used to store the interpolated input_rates. The other three arrays store the discount_rate - calculated form the interpolated input_rates, and the discount_rate perturbed up and down by one basis point ( _p01 and _m01 respectively). This will be used by other objects to calculate their risk as described below.

\subsection{The calculate function}

\subsubsection{The static section}

This static data is available in the calculate function using the provided macros:

\begin{verbatim}
static:
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    date ir_curve_input_rates_asof( NUM_INPUT_RATES )
\end{verbatim}

Given NUM_INPUT_RATES=10, you can use these macros to access the static data in your calculate function as follows:

\begin{verbatim}
    // Get a copy of the first rate
    rate start_rate = ir_curve_input_rates[0];
    // Get a copy of the last rate
    rate end_rate = ir_curve_input_rates[NUM_INPUT_RATES-1];

    // Output the asof date and rate of the start_rate
    cout << "start_rate.asof: " << start_rate.asof << endl;
    cout << "start_rate.value: " << start_rate.value << endl;

    // Loop thought the input rates, outputting the rate and date.
    for ( int i = 0 ; i < NUM_INPUT_RATES ; i++ )
    {
        cout << ir_curve_input_rates_asof( i ) << endl;
        cout << ir_curve_input_rates_value( i ) << endl;
    }

\end{verbatim}

For those financial professionals among you I should make clear that these input_rates contain the bootstrapped forward rates as I've avoided including a bootstrapper to keep things simple. These rates still require interpolation at a daily granularity and conversion into discount factors.

\subsubsection{The pub section}

The pub section is where the results of the object's calculate function are published to the rest of the world. The variables in this section are zeroed when the object starts, and are used as intermediate and final results in the calculate function. If you add a variable to the pub section you will not need to modify the database.  

In this section we have four arrays of doubles of length NUM_FORWARD_DAYS. The interest_rate_interpol array is used to store the interpolated input_rates. The other three arrays store the discount_rate - calculated form the interpolated input_rates, and the discount_rate perturbed up and down by one basis point ( _p01 and _m01 respectively). This will be used by other objects to calculate their risk as described below. 

This pub data can be written to within the calculate function using the provided macros:
\begin{verbatim}
pub:
    double ir_curve_interest_rate_interpol[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_p01[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

Given NUM_FORWARD_DAYS = END_DATE - TODAY, you can use these macros in your calculate function as follows:

\begin{verbatim}
    // Calculate the interpolated rate
    // For details please see bond_risk/objects/ir_curve.c
    ir_curve_interest_rate_interpol[i - TODAY] = ( i*gradient + y_intercept );

    // Calculate the discount factor, plus the two perturbed discount factors
    for ( int i = 0 ; i < NUM_FORWARD_DAYS ; i++ )
    {
        num_years = i / YEAR_BASIS;

        ir_curve_discount_rate[i] = exp( -ir_curve_interest_rate_interpol[i] * num_years );
        ir_curve_discount_rate_p01[i] = exp( -(ir_curve_interest_rate_interpol[i] +0.0001) * num_years );
        ir_curve_discount_rate_m01[i] = exp( -(ir_curve_interest_rate_interpol[i] -0.0001) * num_years );
    }
\end{verbatim}

\section{bond}

\subsection{The t4 files}

\begin{verbatim}
sub
    ir_curve ir_curve

static
    date start_date
    date maturity_date
    int coupons_per_year
    double coupon

pub
    double price
    double pv01
\end{verbatim}

\subsubsection{The sub section}

In the sub section, we can see that bond subscribes to an ir_curve.

\subsubsection{The static section}

In the static section we can see the static data that makes up a simple bond. They have a start_date, the date the bond was issued and is some time in the past. They have a maturity_date when the bond matures - ceases paying out and pays back the 100 you could have bought for at par. The coupons_per_year member describes how often the bond pays, so coupons_per_year=1 pays out once a year and coupons_per_year=4 pays out every quarter. Lastly there's the coupon, which is the rate at which it pays each coupon (e.g. 3% pa).

\subsubsection{The pub section}

The pub section is where the results of bond's calculate function are stored and published. There is the bond's price, calculated form the bond's static and ir_curve's pub section, and pv01 which uses the _p01 and _m01 sections of ir_curve.

\subsection{The calculate function}

\subsubsection{The sub section}

The sub macros available in bond's calculate function pull all the pub and static sections of ir_curve into the scope of the function (from gen/objects/bond_macros.h):

\begin{verbatim}
sub:
    id bond_ir_curve
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    date ir_curve_input_rates_asof( NUM_INPUT_RATES )
    double ir_curve_interest_rate_interpol[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_p01[NUM_FORWARD_DAYS]
    double ir_curve_discount_rate_m01[NUM_FORWARD_DAYS]
\end{verbatim}

We can use these in the calculate function as follows:


\begin{verbatim}

    // Get the discount_rate from ir_curve
    double discount_rate = ir_curve_discount_rate[ir_offset];


\end{verbatim}

\subsubsection{The static section}

The macros for the static section look like this:


\begin{verbatim}

static:
    int bond_start_date
    int bond_maturity_date
    int bond_coupons_per_year
    double bond_coupon

\end{verbatim}

These can be used in the calculate function as follows:

\begin{verbatim}

    double coupon_rate_per_period = bond_coupon / bond_coupons_per_year;

\end{verbatim}


\subsubsection{The pub section}

The pub section macros are as follows:

\begin{verbatim}
pub:
    double bond_price
    double bond_pv01

\end{verbatim}

Which can be assigned to as follows:

\begin{verbatim}
    // Use the discount_rate to discount the future coupon payments and sum
    bond_price = bond_price + ( 100.0 * coupon_rate_per_period * discount_rate );
\end{verbatim}

\section{outright_trade}

The outright_trade's t4 file is as follows:


\begin{verbatim}
sub
    bond bond

static
    double trade_price
    int quantity
    int trade_date

pub
    double pv
    double pv_01
    double pnl
\end{verbatim}

From this we can see that outright_trade subscribes to a bond. In the static section we can see it has a trade_price - the price at which these bonds were purchased, the quantity of bonds purchased and the date of the transaction.

The macros look like this:

\begin{verbatim}
sub:
    id outright_trade_bond
    date bond_start_date
    date bond_maturity_date
    int bond_coupons_per_year
    double bond_coupon
    double bond_price
    double bond_pv01

static:
    double outright_trade_trade_price
    int outright_trade_book
    int outright_trade_quantity
    date outright_trade_trade_date

pub:
    double outright_trade_pv
    double outright_trade_pv_01
    double outright_trade_pnl

\end{verbatim}

The calculate function for outright_trade is shown below in full.

\begin{verbatim}
int calculate_outright_trade( obj_loc_t obj_loc, int id )
{
    // Calculate the pv - the present value of the trade.
    outright_trade_pv = ( outright_trade_quantity * bond_price );

    // Calculate the pv01 - the pv's exposure to interest rate movements.
    outright_trade_pv_01 = ( outright_trade_quantity * bond_pv01 );

    // Calculate the pnl - the profit or loss we would make on the trade if we re-sold these bonds today.
    outright_trade_pnl = outright_trade_pv - ( outright_trade_quantity * outright_trade_trade_price );

    return 1;
}
\end{verbatim}

\section{Operation}

\chapter{Extending bond_risk}

\section{Introduction}

In this chapter we'll extend the model by introducing repo_trades, books and a calendar. The types ir_curve, bond and outright_trade behave as before.

Below, the abstract graph for the enhanced model:

\includegraphics[scale=0.5]{bondriskabstract.png} 

TODO: Fix bondriskabstract.png.

\section{repo_trade}

A repo trade is a kind of secured loan, used by investments banks to raise cash. They are sitting on a pile of bonds they have bought, so they can lend these out in exchange for cash collateral which the banks then use for funding. So they have a start date, and end date and a rate at which interest is calculated on the cash.

Repo trades also need the bond price to calculate their margin, plus a discount rate curve with which to 
calculate the mark-to-market profit and loss (mtm_pnl).

TODO: Explain margin/mtm_pnl, but check other layouts.

- skip t4 files - refer to code

\section{The books}

Trades are grouped into books or portfolios, so all your US-issued bonds might be kept in a book called USBK and your UK-issued ones in a book called UKBK. These books aggregate your risk so you can see overall exposure to particular market force (e.g. US interest rates). There is a book type for each trade type, which gives outright_book and repo_book.

- t4 file and DB example

\section{The calendar}

The calendar type replaces the hard-coded TODAY of bond_risk_simple, and it allows for the date to roll overnight form today to tomorrow. There is only one instantiated calendar object in the system.

- application should be left up week to week (c.f. living with section)

- won't roll rates unless instructed













\section{Operation}


\chapter{Language Features}
\label{sec:Language Features}


In this section we'll be discussing some of the features of trad4 in detail. This is intended to serve a reference, but a read through is suggested.

\section{Constants}

Any application-wide constants can be defined in src/constants.t4s. Anything to the right of a hash is considered a comment and discarded. Constants can also be defined in terms of other constants, and scientific notation is supported. Below, some examples from various trade applications.

\begin{verbatim}
YEAR_BASIS = 365.25     # Number of days in a year

NYQUIST_FREQUENCY = SAMPLE_RATE / 2.0

NUM_BODIES=2
NUM_OTHER_BODIES=NUM_BODIES-1

G=6.673e-11

\end{verbatim}

Be aware that these will be evaluated by the precompiler. If they are not completely described, the precompiler will throw an error.

\section{Enums}


Enums can be defined in src/enums.t4s, e.g.:
\begin{verbatim}
buy_sell_enum
    BUY
    SELL
\begin{verbatim}

These will then be available as types within your .t4 file, e.g.:
\begin{verbatim}
static
    buy_sell_enum buy_sell
\end{verbatim}


And then dereferenced in your calculate function with the usual notation:
\begin{verbatim}
    if ( repo_trade_buy_sell == BUY ) 
\end{verbatim}

These will be represented in the database as integers.

\section{Aliases}

Aliases are just typedefs, and can be defined in src/aliases.t4,s e.g.:

\begin{verbatim}
boolean = int
date = long int
\begin{verbatim}

These will then be available as types within your .t4 file, e.g.:

\begin{verbatim}
static
    date start_date
\end{verbatim}





\section{Arrays}

Arrays in the t4 file are treated differently depending on whether they appear in the pub, static (which are both treated the same) or sub sections. 

\subsection{Static and pub Arrays}

Arrays in the static and pub section work as you'd expect, using any constants you defined above. E.g., in your .t4 file (from test_app/src/tier1.t4):

\begin{verbatim}
static
    double double_array[10]
\end{verbatim}

The macros for these look as you'd expect:

\begin{verbatim}
static:
    double tier1_double_array[10]
\end{verbatim}

These can be used in your calculate function as follows:

\begin{verbatim}
    cout << tier1_double_array[0] << endl;   // Output first double
    cout << tier1_double_array[9] << endl;   // Output last double
\end{verbatim}

Any static arrays also need to persist in the database, and again the table structure is generated for you 
by trad4. The database table will look like:

\begin{verbatim}
create table tier1_double_array (
    id int,
    col0 int,
    col1 int,
    col2 int,
    col3 int,
    col4 int,
    col5 int,
    col6 int,
    col7 int,
    col8 int,
    col9 int
);
\end{verbatim}

So in this case the data for double_array is laid out in columns, so our data looks like this:


\begin {tabular} {| l | l | l | l | l | l | l | l | l | l | l |}
\hline
id & col0 & col1 & col2 & col3 & col4 & col5 & col6 & col7 & col8 & col9 \\
\hline
1 & 0.14 & 1.14 & 2.14 & 3.14 & 4.14 & 5.14 & 6.14 & 7.14 & 8.14 & 9.14 \\
\hline
\end {tabular}


\subsection{Sub Arrays}

- Allowed to be null












\section{Structures}

Structures can be defined in src/structures.t4s:

\begin{verbatim}
rate
    double value
    int asof
\end{verbatim}

These will then be available as types within your .t4 file, e.g.:

\begin{verbatim}
static
    rate ir_rate
\end{verbatim}

These structures are expanded in the macros:

\begin{verbatim}
static:
    rate ir_curve_input_rates[NUM_INPUT_RATES]
    double ir_curve_input_rates_value( NUM_INPUT_RATES )
    date ir_curve_input_rates_asof( NUM_INPUT_RATES )
\end{verbatim}

So ir_curve_input_rates is an array of rate structures, but ir_curve_input_rates_value and ir_curve_input_rates_asof are function-like macros and return the actual rate or date the rate you're interested in, given it's offset. For example:

\begin{verbatim}
    // Get a copy of the first rate
    rate start_rate = ir_curve_input_rates[0];

    // Output the asof date and rate of the start_rate
    cout << "start_rate.asof: " << start_rate.asof << endl;

    // Loop thought the input rates, outputting the rate and date.
    for ( int i = 0 ; i < NUM_INPUT_RATES ; i++ )
    {
        cout << ir_curve_input_rates_asof( i ) << endl;
        cout << ir_curve_input_rates_value( i ) << endl;
    }
\end{verbatim}


Static structures are stored on their own DB tables, so that, assuming that the rate structure above is used in object ir_curve.t4, the associated database table would look like:

\begin{verbatim}
create table ir_curve_input_rates (
    id int,
    ord1 int,
    value float,
    asof int
);
\end{verbatim}

The id is the unique id of the object that these input_rates refer to. The ord1 column is the index of the rate, so that ord1=0 would be the first rate and ord1=NUM_INPUT_RATES-1 the last. The value and asof columns hold the actual data. So our data might look like:

\begin {tabular} {| l | l | l | l |}
\hline
id & ord1 & value & asof \\
\hline
1 & 0 & 0.024 & 40403 \\
\hline
1 & 1 & 0.025 & 40590 \\
\hline
1 & 2 & 0.026 & 40773 \\
\hline
1 & 3 & 0.025 & 41138 \\
\hline
1 & 4 & 0.025 & 41868 \\
\hline
1 & 5 & 0.024 & 42598 \\
\hline
1 & 6 & 0.023 & 43328 \\
\hline
1 & 7 & 0.023 & 44058 \\
\hline
1 & 8 & 0.022 & 45883 \\
\hline
1 & 9 & 0.022 & 47708 \\
\hline
\end {tabular}

See the next chapter for details on how arrays of structures and nested structures are handled.


\chapter{Further Language Features}





\chapter{New Application Walk-through}

\section{Run create_new_app.sh}

Change directory into trad4's bin directory and run the script, giving your new app name as the argument.

\begin{verbatim}
    trad4/bin$ ./create_new_app.sh <app_name>
\end{verbatim}

This will create the directory structure for your new application, plus a couple of files you'll be needing.

For the rest of this chapter substitute simple_maths for your application, or follow along with a downloaded  distribution of simple_maths.

\section{Source your .conf file}

You should always source the relevant .conf file at the beginning of each session to set the environment  up:

\begin{verbatim}
simple_maths$ . ./simple_maths.conf
\end{verbatim}

\section{Write your .t4 files}

Set out the sub, static and pub sections. For example, the .t4 file for the type 'a' from simple_maths is:

\begin{verbatim}
static
    int out
\end{verbatim}

As you can see, this type just has a single static variable of type int. This is loaded when the object is started and doesn't change unless it reloads a new value from the database.

The .t4 file for the type 'x' from simple_maths is:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Type x has a sub section, describing the type and name of the objects to which it subscribes. In this case it's a type a as described above and a type b (not shown, but identical to a.t4). There is one variable in the pub section this is where x publishes it's output value, called 'out' of type int.

The sub types in the .t4 files must always be of another trad4 type. The static and pub types can be of the following built-in C++ types:

\begin{itemize}
\item int
\item char
\item float
\item double
\item long
\end{itemize}

Arrays are supported in the sub, static and pub sections. Also, constants, enums, aliases and structures can be defined and also used in the static and pub sections. More on this later.

\section{Edit your object_types.t4s file}

This file contains an entry for each type:
\begin{verbatim}
#type_id, tier, name
1,1,a
2,1,b
3,1,c
4,1,b
5,2,x
6,2,y
7,3,z
\end{verbatim}

Each type must have it's own unique type_id, it's tier must be specified and it's name must be unique. 
Anything to the right of a hash will be considered a comment and ignored.

In this case there are seven types. The T1 types are a,b,c and d. There are two T2 types x and y, and one T3 type z.

\section{Run the trad4 precompiler}

The precompiler - precomp.pl - is aliased to 't4p':

\begin{verbatim}
    $ t4p
\end{verbatim}

This will create several files under your root directory, the most important of which to you are the files under simple_maths/objects. These files - one per object - contain the stub calculate functions that you must provide the logic for.  You could supply this functionality now, or if you're impatient you can skip to the next step and supply the functionality later.

A generated file you will be needing are the macros under simple_maths/gen/objects and have the file name $<$type$>$_macro.h. There's a comment at the top of this file that shows you what's in scope for the calculate function.

Also generated by the precompiler are the .table files that specify the default database structure. These are found under simple_maths/gen/sql. There is even some dummy data created under simple_maths/data/dummy_data.

The rest of the files produced by the precompiler provide the guts of the trad4 application and you will probably not be interested in. They reside with the macros under simple_maths/gen/objects.

The precompiler supports various command-line options, e.g.:

\begin{verbatim}
simple_maths]$ t4p -h
Usage: precomp.pl [OPTION]
The trad4 precompiler.

  -o <object>    precompile <object> only
  -k             continue on error
  -c             remove all generated files
  -a             remove all generated files and regenerate
  -v             verbose - dumps internal structures
  -d             generate documentation
  -h             display this help and exit
\end{verbatim}

\section{Choose how many threads you need}

To set the number of threads used you set the NUM_THREADS environment variable.

\begin{verbatim}
    $ export NUM_THREADS=16
\end{verbatim}

The default for a new application is 0, which means the master thread does all the work. Setting NUM_THREADS=1 means there is one master thread and one worker thread. The maximum is 4096.

As with all the environment variables, they can be set in app.conf file.


\section{Create the database}

Trad4 uses sqlite, a server-less flat file database. The structure is generated for you by the precompiler, as is some dummy data to get you started.

\begin{verbatim}
    $ recreate_db.sh
\end{verbatim}

This will load the table definitions generated under simple_maths/gen/sql into the DB, and (re)create the 
system tables.

Next, load the default data set:

\begin{verbatim}
    simple_maths/data$ reload_db.sh default_set/
\end{verbatim}

\section{Compile the application}

Note that the default_set will only work reliably if you haven't written your calculate functions yet, as the function may de-reference the dummy data and fail. The default_set is there as a guide to setting up your own data, and a way of getting up and running quickly.

To compile the application, just type make:

\begin{verbatim}
    simple_maths$ make
\end{verbatim}

This will compile and link your application and produce an executable binary of the same name as your 
application. You can run it now if you like. 

\begin{verbatim}
    simple_maths$ bin/simple_maths
\end{verbatim}

You should see the types being created, then the load functions being called and the objects being created (there's a one-to-one correspondence between the types and objects in this simple model). The objects are then validated and a short report is produced. The tiers are then run in turn and all the calculate functions being called, but they won't do anything yet as the logic hasn't yet been provided.

The application should then exit as BATCH_MODE is set as default, which caused the application to exit after the first run.

\section{The Calculate Function}

\section{The Object Data}

\section{Triggering an update}

To trigger an update you first need to set the need_reload flag on the object table to 1 for those objects you want to reload:

\begin{verbatim}
    SQL> update object set need_reload = 1 where id in (...);
\end{verbatim}

You'll then need to unset BATCH_MODE so that the application continues running. Then you send a signal to your application that there's one or more objects that need to be reloaded:

\begin{verbatim}
    $ send_reload.sh 
\end{verbatim}

You will then see all the objects triggering in the order you expect. All the calculate functions will be called, and you should see the affect of your update on the output.

Note that the dummy_data set created for you has need_reload=1 for all objects.

\section{Tips and Tricks}

\subsection{Keep it simple at first}

Keep it simple for now and restrict yourself to two or three types when you're starting a new application.

\subsection{Don't use the heap}

If you feel you need to use the heap you're doing it wrong. If you're convinced you need the heap and you're sure you're not doing it wrong I'd like to hear from you.

\subsection{The init flag}

There's an init flag available in the trad4 internals that is set if the object has fired once. It's useful for initialising certain kinds of objects, particularly in cyclic graphs. E.g. from heat_equation_1d, element.c:

\begin{verbatim}
    if ( ! object_init(id) )
    {
        element_x = (id*1.0)/NUM_NODES;
        element_y = cos( 2*(element_x) );
    }
    else
    {
        element_y = element_y + change_change;
    }
\end{verbatim}

\subsection{The STL is available}

The STL  can be used in your calculate functions, as long as you keep them on the stack. Just include the relevant headers at the top of your calculate function. The following example is from bond.c, and shows using a vector to hold the temporally generated coupon schedule:

\begin{verbatim}
#include <vector>

int calculate_bond( obj_loc_t obj_loc, int id )
{
    std::vector<date> coupon_schedule;
    coupon_schedule.push_back( bond_start_date );

    ...

    std::vector<date>::const_iterator iter = coupon_schedule.begin();

    for ( ; iter != coupon_schedule.end() ; iter++ )
    {
        ...
\end{verbatim}


\subsection{Catch and flag errors}

As discussed in the section on State Management, it's important that the user flags any problems in the calculate function if there's any danger that the pub data has been corrupted. This includes exceptions thrown by external libraries. If there's any doubt that the pub data has been corrupted just return 0 from the calculate function. For example:

\begin{verbatim}
int calculate_bond( obj_loc_t obj_loc, int id )
{
    try {

        ...

    }
    catch ( std::exception& e )
    {
        return 0;
    }

    return 1;
}
\end{verbatim}

\subsection{Common functions}
It is possible to share code between heterogeneous objects. For example, you might require a function that interpolates curves in more than one object in your hierarchy. While there's no formal support for this in trad4 currently, there's nothing stopping you for defining your function in objects/my_func.c, and then doing a crafty:

\begin{verbatim}
#include "my_func.c"
\end{verbatim}

In each object's calculate file that needs it. Your function will have to be trad4-compliant, i.e. there should be no use of the heap etc. 

\subsection{Environment variables}
In this section some useful environment variables are listed. You can either export them locally from your shell or set them in your .conf file.

NUM_THREADS controls the number of worker threads used. The maximum is set to a rather unreasonable 4096. If you set it to 0 this will activate the single-threaded mode where the master thread runs the calculate function - useful for benchmarking, and stepping through the operation without getting a headache.

BATCH_MODE if set to 1 will terminate the application after the first run through. Useful during the early staged of development and benchmarking.

TIMING_DEBUG controls whether the tier-level timing is displayed. Generally you'll want it off  (0) if you're doing multiple iterations and on (1) if you're doing intensive calculations per-tier.

APP_DB points to the current sqlite .db file. The default is data/<application>.db

CXXFLAGS contain the compilation flags. Default is "-c -Wall -fPIC". Append with your own e.g.  -O3, -g.

T4_3RD_PARTY_LIBS contains the colon-separated paths to any third-party libraries you're using.

T4_3RD_PARTY_HEADER_PATH contains the colon-separated paths to any third-party headers you need to include.

\chapter{Living with trad4}

In this section we'll look at some of the issues that will arise in real-world deployments.

\subsection{Porting your existing applications to trad4}

And now, the bad news: To port your existing applications to the trad4 architecture you're looking at a re-write. There are several reasons for this:

Firstly, because even if the application or library you were porting was thread-safe, it would likely be thread safe in the classical sense with locks and such, so you'd be introducing all the downsides of a classical multi-threaded program (complexity, deadlocks, difficulty debugging etc.) by using the library as it stands.

The second reason is your existing data structures would likely be incompatible with the trad4 
layout.

Lastly, your existing application is likely to make extensive use of the heap. The lack of support for the heap in trad4 would also probably break any caching mechanism you currently use.

TODO: jpm_cds

The news is not all bad, though as the port is likely to be mostly a cut-and-paste job. Here this discussion gets difficult as I can only try and imagine your application, but take once again the example of bond_risk.

Somewhere in your conventionally architectured bond_risk application will be some code to price a bond. It will use different data structures but it's actual operation will be the same in both systems. Any 
switches based on day-count conventions for example, should be able to be copied across without much modification.

Likewise you'll already have the code to bootstrap interest rate curves. Again you'll have to find/replace the accessors used, but the logic of the functions should be the same.

The other bit of good news is that at the end of the day, your numbers in both systems should match, so as a result of the port your risk numbers shouldn't move.

That's the bad news over with.

\subsection{Adding, removing and correcting objects at run-time}

Trad4 object should not change their identity during run-time. That means while it's fine to correct a bond's maturity date if it was first entered in error, but it would be inappropriate to change the identity of a bond from one to another. If a trade is attached to the wrong bond you don't update the bond, you update the trade to point to the correct bond.

\subsection{Corrections}

To correct an object update the object's data in the DB and set need_reload=1. Send the signal and the object's data is reloaded.

\subsection{Additions}

To add an object just add it's row in the relevant tables and once again send the reload signal. This object now starts. 

The thing you have to think about is what other connections this object has. It's trivial to add say an outright_trade at run-time as no objects subscribe to outright_trades in our model - they are at the top of the graph. If you were adding a bond, say, you'd have to give some thought to what trades connect to it.  In practise you'd probably be adding a bond because someone has just booked a trade against it. In this case you'd have to take care to start the bond before the trade, or start them both at the same time.

\subsection{Deletions}

The problem with additions becomes clearer when it comes to deletions. Were you to delete a bond that had attached trades, the behaviour of trad4 is currently undefined \footnote{But almost certainly bad.}.

\section{Adding and removing types at run-time}

As well as adding objects, you can also add new types while the system is running. Each type resides in it's own shared library which are loaded dynamically at run-time. To add a new type to a running trad4 application you:

\begin{enumerate}
\item Specify the object in the .t4 file. Run the precompiler and compile.
\item Add a row to the object_types table with need_reload=1
\item Trigger trad4 to reload the type.
\end{enumerate}

Trad4 will then load the new library and initialise the various structures. You can now add objects of this type as discussed above.

As always, care must be taken that you don't screw everything up. Changing a running type is inadvisable - you'd be better off creating a new type with the requisite changes and load that. Then migrate your object across from the old type to the new. During the weekly rebalancing (see below) you'd clean up the old type and tidy up the naming of the new.

\section{Working with multiple boxes}

In all the examples we've disused so far we've been working with a single box which is capable of running  all our objects. In large scale trad4 applications this will not be the case.

Say for example you have 100 books, each with hundred trades in each and assume a single box can't run this. We're sticking with bond_risk, so say 70% of the books are outright books and the rest are 
repo. Trades are divided into books roughly by the industry sector of the bonds. You have ten identical boxes all with plenty of cores and plenty of ram. How best to divide up the problem?

Your first instinct might to be to run ten books on each box, just ensuring that the number of trades on each box was roughly equal. The problem with this approach is that as the bonds in each book in the same sector, they are closely correlated. This close correlation means that were there a heavy day's trading in that sector you'd get one hot box and nine cool ones.

Far better to arrange your data so that objects of the same type share a box with those it's poorly correlated to. One way you'd do this is, as you're working through the trades in a particular book, assign them each to a different box in turn. As you reach the tenth box just start again from box one. In this way you ensure all your sectors are spread evenly across multiple boxes.

This approach does have one disadvantage in that you'll need to run all the ir_curves on every box, but as there are a small number of these (relative to the number of trades) this should not be a problem.

\section{Weekly rebalancing}

It is recommended that you shut your application down once a week for maintenance. The tasks you might want to perform are:

\subsection{Reassign any unused ids}

As objects are added and removed, the id's you use will become fragmented. While the system was down you would want to reassign these unused ids to known objects and free up space at the top of your id array for new objects the following week.

\subsection{Adding new and removing old types}

If you added new object types at runtime you might want to re-arrange them more comfortably in the configuration files. Likewise if you removed any object types when the system was up you would want to remove these from the system and reassigning the type ids.

\subsection{Check your headroom}

As trad4 relies wholly on fixed length arrays, running out of space mid-week should be avoided.  Meanwhile, while you need to keep a careful eye on your headroom and adjust your model parameters as necessary. If needs be, throw more hardware at the problem.

\subsection{Dynamic debug}

Dynamic debug is supported so you can set debug level at run-time on a per-object basis. 

There are four debug levels:

\begin{itemize}
\item log_level=0 will display no output
\item log_level=1 will display the published values
\item log_level=2 will show the above and the subscribed-to values
\item log_level=3 will show the above plus the workings of the need_refresh function
\end{itemize}

To set an object's log_level, run the sqlite3 client, aliased 't4db'

\begin{verbatim}
$ t4db
SQL> update object set log_level = <log level> where id = <id>
\end{verbatim}

Then run send_reload to pick up the changes:

\begin{verbatim}
$ need_refresh.sh
\end{verbatim}

Note: For this change to be picked up the object's need_reload flag on the object table will have to be set to 1. This is the default in most data sets in order to simplify the demonstration, but if your debug changes aren't being picked up you should check this flag.

\chapter{Hardware considerations}

\appendix

\chapter{How trad4 works}

\end{document}

