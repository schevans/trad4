% Copyright (c) Steve Evans 2010
% steve@topaz.myzen.co.uk


\documentclass{report}

\usepackage{underscore}
\usepackage{times}
\usepackage{graphicx}

\begin{document}

\title{The Manual}
\author{Steve Evans}
\maketitle

\chapter{Introduction}

Trad4 is a programming language with which you describe the relationship and behaviour of a set of object of different types. 

Time for an example.

\chapter{Example: Hello world!}

\section{Introduction}

The first trad4 application we'll examine is the venerable "Hello world!".

\includegraphics[scale=0.5]{helloworldabstract.png}

The above application is a directed acyclic graph, and it shows three types. Two on tier1 (T1) - hello and world, and one on T2 - hello_world. The T2 hello_world object subscribes to the two T1 objects. The hello_world object simple concatenates the names of the two objects and prints them out.

What will happen when the application starts is that the T1 objects will run concurrently (they do nothing in this simple example), then the T2 object will run. This will read the names of the T1 objects and concatenate them and print the result. The output is below.


\begin{verbatim}
~/src/hello_world$ hello_world
Creating new type hello, type_id: 1
Creating new type world, type_id: 2
Creating new type hello_world, type_id: 3
Loading objects...
Loading hello..
Loading world..
Loading hello_world..
Validating objects...

Num objects in tier1: 2
Num objects in tier2: 1

Running in single-threaded mode.

Tier 1 running.
Tier 1 ran 2 objects in 6.60419e-05 seconds.

Tier 2 running.
Hello world!
Tier 2 ran 1 objects in 2.88486e-05 seconds.

All tiers ran 3 objects in 0.000231981 seconds.

Exiting after first run as BATCH_MODE is set.
\end{verbatim}

When the application hello_world starts, it first creates the three types we discussed above. Next the objects themselves are loaded. Next the objects are validated and the number of objects on each tier reported. This application is set to use single-threaded mode to keep the output orderly. 

Next we'll see how these types are defined.

\section{The .t4 files}

The way types are defined is in their *.t4 file in the src directory. The types hello and world are the simplest possible as they do absolutely nothing and thus .t4 files are empty, but hello_world.t4 is shown below:

\begin{verbatim}
sub
    hello hello
    world world
\end{verbatim}

The .t4 files are split into three sections. The sub section as shown above describes the type and name of the other trad4 types to which this this type subscribes. In this case hello_world subscribes to two types, the first being a hello object called hello, and the second a world object called world.

Each type must also have an entry in the object_types.t4s file (the 's' stands for system). This is shown below:

\begin{verbatim}
#type_id, tier, name
1,1,hello
2,1,world
3,2,hello_world
\end{verbatim}

The type_id muse be unique. From this we can see type hello has an id of 1 and exists on tier 1 and world has an id of 2 and also exists on tier 1. The hello_world type has an id of 3 and exists on tier 2.

\section{The Calculate Function}

Now we have described the type, we must specify what is does, in this case concatenating the names of the two objects and printing it out.

A stub calculate function is generated for you by trad4, and is found in the objects directory. Again, hello and world do nothing but hello_world's calculate function is shown below:

\begin{verbatim}
int calculate_hello_world( obj_loc_t obj_loc, int id )
{
    cout << object_name(hello_world_hello) << " " << object_name(hello_world_world) << "!" << endl;

    return 1;
}
\end{verbatim}

Trad4 pulls all the information from the sub objects into the scope of this function using macros. You need not concern yourself how these macros work, just think of then as variables which will do what you expect. The functions signature is boilerplate to allow the macros to work and should be ignored. Also ignore return value for now.

In this case there's very little information in the sub objects, just their id. The macros used above are shown below (from gen/objects/hello_world_macros.h):

\begin{verbatim}
sub:
    id hello_world_hello
    id hello_world_world
\end{verbatim}

So this shows that within calculate_hello_world there's a variable hello_world_hello in scope that will return the id of the hello object. Likewise there's a variable hello_world_world that will return the id of the world object. These id's we can use in the trad4 object_name function to return the name of the object, which is exactly what calculate_hello_world does above.

\chapter{Example: Simple Maths}

\section{Introduction}

We're going to move on to a more complex example in order to demonstrate the concurrency. We want to model the following simple equation:

\begin{math}
  \begin{array}{ l c }
        & z = x + y   \\
        where         \\
        & x = a + b   \\
        & y = c + d   \\
        and           \\
        & a = 7       \\
        & b = 14      \\
        & c = 6       \\
        & b = 27      \\
  \end{array} 
\end{math}

The abstract diagram for simple_maths is as follows:

\includegraphics[scale=0.5]{simplemathsabstract.png}

From this we can see that should a, b, c, and d all change we can run x and y at the same time, followed by z. Likewise, if only a changes we only need to recalculate x. Another point to note it that there is just one instance of \begin{math} a + b\end{math} in the whole system - any other object that requires that result subscribe to the x object and read it from there. We will see later how it's possible to decompose quite complex problems into trad4 applications and have fragments of them run concurrently.

\section{The .t4 Files}

In this example the .t4 files are a little more interesting. Below, a.t4:

\begin{verbatim}
static
    int out
\end{verbatim}

Here type a has only one member, it's in the static section and it's an int called out. It's in the static section as the data is stored in the database. More on this below.

The .t4 file for b, c and d are identical to a's and not shown. The .t4 file for x is shown below:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Here type x has three members. The first two are in the sub section and shows x subscribes to a type a called a, and a type b of name b. It also has an int called out in the pub section, where the result of \(a + b\) will be stored to be consumed by z.

The .t4 files for y and z are similar to x's and not shown. In fact there's a more concise way to arrange similar t4 types using inheritance of interface (IoI), as discussed in general_computer below.

\section{The Calculate Function}

The calculate functions for a, b, c and d do nothing, as they consist entirely of a single static member which is just published to to the world at large without any processing. The calculate_x function is shown below:

\begin{verbatim}
int calculate_x( obj_loc_t obj_loc, int id )
{
    x_out = a_out + b_out;

    return 1;
}
\end{verbatim}

Again these variables are provided by macros (from gen/objects/x_macros.h):


\begin{verbatim}
sub:
    id x_a
    int a_out

    id x_b
    int b_out

static:

pub:
    int x_out
\end{verbatim}

Here you can see for each sub member two variables are provided, in a's case these are x_a which provides it's id, and a_out where a will publish it's static data. Also in the pub section is the int x_out, where the result of  \(a + b\) is published. So calculate_x takes the published a_out and b_out variables, adds them and publishes the result in x_out.

The calculate functions for y and z are very similar to that of x and is not shown.

\section{The Data}

In the first example hello_world we ignored the database. This is a serverless sqlite db, the structure of which is generated for you by the precompiler. At this stage we also need to distinguish between objects and types.

Types are the trad4 types as described in their .t4 files and calculate function. Objects are the running, instantiated types, described in the database. This discussion is confused by the fact that in this app and hello_world, each type has a single instantiate object, but this will become clearer later as we have multiple objects of particular types.

The main table int the database is the object table, which every object has an entry in. This table is shown below:
 
\begin{verbatim}
create table object (
    id int, 
    type_id int,
    tier int,
    name char(32),
    log_level int,
    need_reload int
);
\end{verbatim}

The id is the unique id of this object. The type_id gives the type of the object, as described in the object_types.t4s file described above. The tier gives the tier this object exists on, as objects of the same type can exist on different tiers in certain circumstances as discussed below (IoI). The name field holds the name of the object which we pressed into service in hello_world. The log_level controls the level of logging the object does, and need_reload controls whether of not the object needs to be reloaded when the application receives a reload signal (more on this later).

As well as the object table, each type has one or more type-specific tables. In simple_maths this is just one table per type. Below is the table for a (from gen/object/sql):


\begin{verbatim}
create table a (
    id int,
    out int
);
\end{verbatim}

There is the primary key id, plus the static value of the out variable. So the data for object a of type a is given by (from data/worked_example/a.sql):

\begin{verbatim}
insert into object values ( 1, 1, 1, "a", 2, 1 );
insert into a values ( 1, 7 );
\end{verbatim}

So we can see an object with id of 1, type 1 running on tier 1 called "a" with log_level 2 and need_reload set to 1. In type-specific table a there's the primary key id and the value of out, given by 7. The data for objects b, c and d are similar to this, except they have different ids, type_ids, names and static out values as described above. The data for object x is given by:


\begin{verbatim}
insert into object values ( 5, 5, 2, "x", 2, 1 );
insert into x values ( 5, 1, 2 );
\end{verbatim}

This shows an object with id 5, type 5, tier 2 etc. In type-specific table x there's the primary key id and the ids of the two objects to which x subscribes, namely a with id 1 and b with id 2. 







\chapter{New Application Walkthrough}

\section{Run create_new_app.sh}

Change directory into trad4's bin directory and run the script, giving your new app name as the argument.

\begin{verbatim}
    trad4/bin$ ./create_new_app.sh <app_name>
\end{verbatim}

This will create the directory structure for your new application, plus a couple of files you'll be needing.

For the rest of this chapter substitute simple_maths for your application, or follow along with a downloaded  distribution of simple_maths.

\section{Source your .conf file}

You should always source the relevant .conf file at the beginning of each session to set the environment  up:

\begin{verbatim}
simple_maths$ . ./simple_maths.conf
\end{verbatim}

\section{Write your .t4 files}

Set out the sub, static and pub sections. For example, the .t4 file for the type 'a' from simple_maths is:

\begin{verbatim}
static
    int out
\end{verbatim}

As you can see, this type just has a single static variable of type int. This is loaded when the object is started and doesn't change unless it reloads a new value from the database.

The .t4 file for the type 'x' from simple_maths is:

\begin{verbatim}
sub
    a a
    b b

pub 
    int out
\end{verbatim}

Type x has a sub section, describing the type and name of the objects to which it subscribes. In this case it's a type a as described above and a type b (not shown, but identical to a.t4). There is one variable in the pub section this is where x publishes it's output value, called 'out' of type int.

The sub types in the .t4 files must always be of another trad4 type. The static and pub types can be of the following built-in C++ types:

\begin{itemize}
\item int
\item char
\item float
\item double
\item long
\end{itemize}

Arrays are supported in the sub, static and pub sections. Also, constants, enums, aliases and structures can be defined and also used in the static and pub sections. More on this later.

\section{Edit your object_types.t4s file}

This file contains an entry for each type:
\begin{verbatim}
#type_id, tier, name
1,1,a
2,1,b
3,1,c
4,1,b
5,2,x
6,2,y
7,3,z
\end{verbatim}

Each type must have it's own unique type_id, it's tier must be specified and it's name must be unique. 
Anything to the right of a hash will be considered a comment and ignored.

In this case there are seven types. The T1 types are a,b,c and d. There are two T2 types x and y, and one T3 type z.

\section{Run the trad4 precompiler}

The precompiler ­ precomp.pl ­ is aliased to 't4p':

\begin{verbatim}
    $ t4p
\end{verbatim}

This will create several files under your root directory, the most important of which to you are the files under simple_maths/objects. These files ­ one per object ­ contain the stub calculate functions that you must provide the logic for.  You could supply this functionality now, or if you're impatient you can skip to the next step and supply the functionality later.

A generated file you will be needing are the macros under simple_maths/gen/objects and have the file name $<$type$>$_macro.h. There's a comment at the top of this file that shows you what's in scope for the calculate function.

Also generated by the precompiler are the .table files that specify the default database structure. These are found under simple_maths/gen/sql. There is even some dummy data created under simple_maths/data/dummy_data.

The rest of the files produced by the precompiler provide the guts of the trad4 application and you will probably not be interested in. They reside with the macros under simple_maths/gen/objects.

The precompiler supports various command­line options, e.g.:

\begin{verbatim}
simple_maths]$ t4p -h
Usage: precomp.pl [OPTION]
The trad4 precompiler.

  -o <object>    precompile <object> only
  -k             continue on error
  -c             remove all generated files
  -a             remove all generated files and regenerate
  -v             verbose - dumps internal structures
  -d             generate documentation
  -h             display this help and exit
\end{verbatim}

\section{Choose how many threads you need}

To set the number of threads used you set the NUM_THREADS environment variable.

\begin{verbatim}
    $ export NUM_THREADS=16
\end{verbatim}

The default for a new application is 0, which means the master thread does all the work. Setting NUM_THREADS=1 means there is one master thread and one worker thread. The maximum is 4096.

As with all the environment variables, they can be set in app.conf file.


\section{Create the database}

Trad4 uses sqlite, a serverless flat file database. The structure is generated for you by the precompiler, as is some dummy data to get you started.

\begin{verbatim}
    $ recreate_db.sh
\end{verbatim}

This will load the table definitions generated under simple_maths/gen/sql into the DB, and (re)create the 
system tables.

Next, load the default data set:

\begin{verbatim}
    simple_maths/data$ reload_db.sh default_set/
\end{verbatim}

\section{Compile the application}

To compile the application, just type make:

\begin{verbatim}
    simple_maths$ make
\end{verbatim}

This will compile and link your application and produce an executable binary of the same name as your 
application. You can run it now if you like. 

\begin{verbatim}
    simple_maths$ bin/simple_maths
\end{verbatim}

You should see the types being created, then the load functions being called and the objects being created (there's a one-to-one correspondence between the types and objects in this simple model). The objects are then validated and a short report is produced. The tiers are then run in turn and all the calculate functions being called, but they won't do anything yet as the logic hasn't yet been provided.

The application should then exit as BATCH_MODE is set as default, which caused the application to exit after the first run.

\section{The Calculate Function}

\section{The Object Data}

\section{Triggering an update}

To trigger an update you first need to set the need_reload flag on the object table to 1 for those objects you want to reload:

\begin{verbatim}
    SQL> update object set need_reload = 1 where id in (...);
\end{verbatim}

You'll then need to unset BATCH_MODE so that the application continues running. Then you send a signal to your application that there's one or more objects that need to be reloaded:

\begin{verbatim}
    $ send_reload.sh 
\end{verbatim}

You will then see all the objects triggering in the order you expect. All the calculate functions will be called, and you should see the affect of your update on the output.

Note that the dummy_data set created for you has need_reload=1 for all objects.

\section{Tips and Tricks}

Keep it simple for now and restrict yourself to two or three types when you're starting a new application.

\chapter{Further Language features}

\chapter{Tips and tricks}

\chapter{Living with trad4}

\chapter{Hardware considerations}

\appendix

\chapter{How trad4 works}

\end{document}

