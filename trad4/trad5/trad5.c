// Copyright (c) Steve Evans 2008
// steve@topaz.myzen.co.uk
//

#include <iostream>
#include <pthread.h>
#include <sys/time.h>

#include "trad5.h"
#include "common.h"
#include "bond.h"
#include "discount_rate.h"
#include "interest_rate_feed.h"

using namespace std;

void* obj_loc[NUM_OBJECTS+1];

void fire_object( int id );
void run();

// For prototype only 
//  Mimics the IR feed.
void bump_rates();
//  Loads data into memory
void setup_mem();

// This is only called by the master thread, but it's a reader, so that's ok.
// These will be generated by trad5.
extern bool bond_need_refresh( int );
extern bool discount_rate_need_refresh( int id );

// This is only ever called from the object threads, as it's a writer.
void set_timestamp( int id );

// Provided by the user.
void* calculate_bond( void* id );
void* calculate_discount_rate( void* id );
void* calculate_interest_rate_feed( void* id );

int main() {

    setup_mem();

    // Fire off the feed once and let it terminate. This will populate rate_interpol
    fire_object( 1 );

    run();

}

void fire_object( int id )
{
    pthread_t t1;

    ((object_header*)obj_loc[id])->status = RUNNING;

    if ( pthread_create(&t1, NULL, (*((object_header*)obj_loc[id])->calculator_fpointer), (void *)id) != 0 ) {
        cout << "pthread_create() error" << endl;
        abort();
    }
}

void set_timestamp( int id )
{
    timeval time;
    gettimeofday( &time, NULL );
    int sec = time.tv_sec;
    int mil = time.tv_usec;

    int timestamp = (( sec - 1203000000 ) * 1000 ) + ( mil / 1000 );

    // I know this looks strange but we 'know' the first element in the struct (pointed to
    //  by obj_loc[id]) is an int, regardless of the type of the struct.
    *(int*)obj_loc[id] = timestamp;

    ((object_header*)obj_loc[id])->status = STOPPED;
}

void run()
{
    int bump_rates_counter(1);
    
    while (1) 
    {
        for ( int i=1 ; i <= NUM_OBJECTS ; i++ )
        {
            // First check if the object *has* a need_refresh_fpointer
            //  If it doesn't it's a feed.
            if ( ((object_header*)obj_loc[i])->need_refresh_fpointer )
            {
                // Ok it's a CaclObject. Call the function.
                if ( (*((object_header*)obj_loc[i])->need_refresh_fpointer)(i) )
                {
                    fire_object( i );            
                }
            }

        }

        // Bump rates every few seconds to simulate market moving.
        if ( bump_rates_counter++ % 20000000 == 0 )
        {
            bump_rates();
            fire_object( 1 );
        }

    }
}

// For prototype only - mimics the IR feed.
// In the final version I'll probably put the feed structs in shmem so other processes can write to them.
void bump_rates()
{
    cout << "\nRates bumped" << endl;

    double peturbation = ( rand() / (double)RAND_MAX ) - 0.5;

    for ( int i=0 ; i < INTEREST_RATE_LEN ; i++ )
    {
        ((interest_rate_feed*)obj_loc[1])->rate[i] =+ peturbation;
    }
}

void setup_mem() 
{
    obj_loc[1] = new interest_rate_feed;
    ((interest_rate_feed*)obj_loc[1])->last_published = 0;
    ((interest_rate_feed*)obj_loc[1])->status = STOPPED;
    ((interest_rate_feed*)obj_loc[1])->calculator_fpointer = &calculate_interest_rate_feed;
    ((interest_rate_feed*)obj_loc[1])->need_refresh_fpointer = 0; // It's a feed.
    ((interest_rate_feed*)obj_loc[1])->type = 0;
//    ((interest_rate_feed*)obj_loc[1])->name = 0;
    ((interest_rate_feed*)obj_loc[1])->sleep_time = 0;

    ((interest_rate_feed*)obj_loc[1])->ccy = 0;

    ((interest_rate_feed*)obj_loc[1])->asof[0] = 10000;
    ((interest_rate_feed*)obj_loc[1])->asof[1] = 11000;
    ((interest_rate_feed*)obj_loc[1])->asof[2] = 12000;
    ((interest_rate_feed*)obj_loc[1])->asof[3] = 13000;
    ((interest_rate_feed*)obj_loc[1])->asof[4] = 14000;
    ((interest_rate_feed*)obj_loc[1])->asof[5] = 15000;
    ((interest_rate_feed*)obj_loc[1])->asof[6] = 16000;
    ((interest_rate_feed*)obj_loc[1])->asof[7] = 17000;
    ((interest_rate_feed*)obj_loc[1])->asof[8] = 18000;
    ((interest_rate_feed*)obj_loc[1])->asof[9] = 20000;

    ((interest_rate_feed*)obj_loc[1])->rate[0] = 2.3;
    ((interest_rate_feed*)obj_loc[1])->rate[1] = 2.4;
    ((interest_rate_feed*)obj_loc[1])->rate[2] = 2.5;
    ((interest_rate_feed*)obj_loc[1])->rate[3] = 2.5;
    ((interest_rate_feed*)obj_loc[1])->rate[4] = 2.4;
    ((interest_rate_feed*)obj_loc[1])->rate[5] = 2.3;
    ((interest_rate_feed*)obj_loc[1])->rate[6] = 2.2;
    ((interest_rate_feed*)obj_loc[1])->rate[7] = 2.2;
    ((interest_rate_feed*)obj_loc[1])->rate[8] = 2.2;
    ((interest_rate_feed*)obj_loc[1])->rate[9] = 2.1;

    cout << "New interest_rate_feed created" << endl;
    
    obj_loc[2] = new discount_rate;

    ((discount_rate*)obj_loc[2])->last_published = 0;
    ((discount_rate*)obj_loc[2])->status = STOPPED;
    ((discount_rate*)obj_loc[2])->calculator_fpointer = &calculate_discount_rate;
    ((discount_rate*)obj_loc[2])->need_refresh_fpointer = &discount_rate_need_refresh;
    ((discount_rate*)obj_loc[2])->type = 0;
//    ((discount_rate*)obj_loc[2])->name = 0;
    ((discount_rate*)obj_loc[2])->sleep_time = 0;

    ((discount_rate*)obj_loc[2])->interest_rate_feed = 1;
    ((discount_rate*)obj_loc[2])->ccy = 0;

    cout << "New discount_rate created" << endl;

    obj_loc[3] = new bond;

    ((bond*)obj_loc[3])->last_published = 0;
    ((bond*)obj_loc[3])->status = STOPPED;
    ((bond*)obj_loc[3])->calculator_fpointer = &calculate_bond;
    ((bond*)obj_loc[3])->need_refresh_fpointer = &bond_need_refresh;
    ((bond*)obj_loc[3])->type = 0;
//    ((bond*)obj_loc[3])->name = 0;
    ((bond*)obj_loc[3])->sleep_time = 0;

    ((bond*)obj_loc[3])->discount_rate = 2;
    ((bond*)obj_loc[3])->coupon = 2.2;
    ((bond*)obj_loc[3])->start_date = 5000;
    ((bond*)obj_loc[3])->maturity_date = 15000;
    ((bond*)obj_loc[3])->coupons_per_year = 4;
    ((bond*)obj_loc[3])->ccy = 0;
    ((bond*)obj_loc[3])->price = 0.0;
    ((bond*)obj_loc[3])->dv01 = 0.0;

    cout << "New bond created" << endl;
}
